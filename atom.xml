<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shaojin&#39;s Words</title>
  
  <subtitle>如果有一天有人问你，你觉得我这个人怎么样，你能略加思考的说他是一个有趣的人，那么我就会很开心!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-09T15:45:24.868Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>程少进</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018年春节前最后一天上班的晚上</title>
    <link href="http://yoursite.com/2018/02/09/2018%E5%B9%B4%E6%98%A5%E8%8A%82%E5%89%8D%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%E4%B8%8A%E7%8F%AD%E7%9A%84%E6%99%9A%E4%B8%8A/"/>
    <id>http://yoursite.com/2018/02/09/2018年春节前最后一天上班的晚上/</id>
    <published>2018-02-09T15:04:34.000Z</published>
    <updated>2018-02-09T15:45:24.868Z</updated>
    
    <content type="html"><![CDATA[<p>晚上收拾了下明天回家的行李，想想一年就这样又过去了，是不是应该总结一下过去一年的得失、荣辱、希望和失望，这样也给自己一种仪式感，写一写感悟，谈一谈一年中的改变，想一想18年应该做哪些事，提醒自己不负时光，能光明前进。</p><p>慢慢静下心来，匆匆2018年也已经是2月份了，这两月工作不是特别的忙，上班时间基本也是自己安排，也让自己放松了很多，下班后都是看小说，没干什么正事，熬了几个夜晚看完了曾国藩三部曲，导致自己最近总是爱琢磨别人说的话到底有什么深层意思，其实也没有什么意思，平常人哪有那么高深莫测，没干啥事反而让自己很累。后来就自己劝自己我等凡夫俗子就别想那么多了，别人一张口就知道人家心里想什么的内家本事，没个几十年的功力哪能轻易练成，哈哈。开个玩笑，还是说说自己到底干了什么吧。</p><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>这一年发生最重要的事就是在十月份换了工作，这是我没有想到的，虽然依然在同一个行业，但在一家公司呆的时间太短总不是一件太好的事，再说当时的领导对初入职场的我在做人做事各方面有很大的帮助，很多事都是亲历亲为的教我们，我很感谢他，希望他在新的一年工作顺利，身体健康。然后因为很多其他原因，当然也有一部分我自己的原因，就匆匆辞职了换了一份工作，依然在做openstack运维实施方面的工作。其实当时刚毕业的时候自己真的是十分的迷茫，不知道自己能干什么，看到openstack正如日中天，就开始学习，现在也能因此谋得一份工作也感到十分的庆幸。即使openstack呈下落趋势，任何开源项目都有其上升期和下降期，但是现在也会因为工作需要去不断的学习新的知识，不再因为不知道自己能干什么想干什么而迷茫，我想这应该是自己这一年最大的收获吧。</p><p>其实工作中能识人然后正确的待人也是工作实力的一部分，刚出校门的我，因为说话做事太直，吃了不少的亏，吃一斩长一智嘛，现在想来其实吃吃亏也是蛮好的。让自己认识到自己情商的严重不足，应该注意慢慢提高。我也一直在提醒自己要不忘初心，做人做事要有自己的底线，不要变得太圆滑，成为自己以前讨厌的人。</p><h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>离开校园生活变得非常规律了，以前在学校总是抽烟，现在也不抽了，其实我是没有烟瘾的，所以说戒就戒了。自从离开学校开始租房子了，周末有时间就开始自己做饭了，这一点是我非常开心的，生活的情趣来源于不断的创造，尤其当你做出一盘色香味俱全的菜的时候，那种成就感是不由而生的。由此也感受到，其实每天做饭也是一件非常耗时间的，而且加上洗锅也是比较累的，做饭的时候信心满满，但是吃完就不想洗锅了，哈哈，争取以后就买自动洗碗机了，看了网上的评论，说是还不错。今年回家一定帮妈妈多洗几次碗。<br>一年也没怎么出去旅行，大学的时候没钱，反而经常出去玩，在北京一年多，连北京市也没怎么玩过，国庆放假的时候计划好了出去，结果加了四天班，也再没心情出去了，以后心态有待改正，不工作的时候还是应该多出去看看的，尤其一些自然风景区，大自然自带一种开阔心胸的功能。<br>唯一遗憾的就是自从毕业就很少再踢球了，这项占据了大学最多时间的运动，现在却很少去踢了。我也能感觉到身体机能大不如以前了，总想着去锻炼，但都是时间用来做了其他事了，其实归根结底还是太懒了。很怀念当年参加大学生运动会的时候跟球队吃住在一起的日子以及每天下午在操场练球的日子。</p><h3 id="2018年计划要做的："><a href="#2018年计划要做的：" class="headerlink" title="2018年计划要做的："></a>2018年计划要做的：</h3><p>1.学驾照。虽说人工智能的突飞猛进已经实现了无人驾驶，但还是想体验驾驶的乐趣。一定要做的。<br>2.学习python语言。简直刻不容缓啊。<br>3.能初学投资，虽然没钱，但我也有一颗想实现财富自由的心啊。<br>4.能读20本以上的书。20本应该很少了，比不了大神，自己开心就好，貌似最近没咋上心工作，下班已经读了三四本了吧，主要是必须要完成，没有上线，不要辜负了自己的kindle。哈哈。<br>5.提高自己的厨艺，会做菜品的数量有待丰富，没有多大要求，能满足家常就好了。</p><p>絮絮叨叨没说啥正事，感觉都是废话啊。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;晚上收拾了下明天回家的行李，想想一年就这样又过去了，是不是应该总结一下过去一年的得失、荣辱、希望和失望，这样也给自己一种仪式感，写一写感悟，谈一谈一年中的改变，想一想18年应该做哪些事，提醒自己不负时光，能光明前进。&lt;/p&gt;
&lt;p&gt;慢慢静下心来，匆匆2018年也已经是2月份
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>docker单机环境下的网络与通信</title>
    <link href="http://yoursite.com/2018/01/22/docker%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2018/01/22/docker单机环境下的网络与通信/</id>
    <published>2018-01-22T02:09:14.000Z</published>
    <updated>2018-01-26T02:33:58.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、docker单机环境的下的网络"><a href="#一、docker单机环境的下的网络" class="headerlink" title="一、docker单机环境的下的网络"></a>一、docker单机环境的下的网络</h2><h3 id="1-三种原生网络"><a href="#1-三种原生网络" class="headerlink" title="1.三种原生网络"></a>1.三种原生网络</h3><p>docker提供三种原生网络，在安装的时候就会自动在host创建三个网络，用 docker network ls 命令查看，分别是：bridge、host、none。在创建容器的时候可以通过--network=none/host/bridge 来指定使用哪一种网络。例如：</p><pre><code># docker run -it --network=none busybox</code></pre><p>none网络：什么都没有的网络，这个网络的容器只有一个lo网卡，是一个网络封闭的容器，对一些安全性较高，不需要联网的应用可以使用none网络。<br>host网络：使用host网络的容器与主机的网络配置完全一样，连hostname都一样。host网络的好处是性能好，但是不够灵活。比如端口与host会冲突.<br>bridge网络：安装docker的时候都会默认创建一个 docker0 的linux bridge，如果不指定网络，默认创建的容器的网络都会挂在 docker0 上。bridge网络的容器有一对veth pair,是一对连起来的网卡，一边在容器里，一边挂在host的docker0 上，这样相当于容器里的一头也挂在 docker0 上。用 docker network inspect bridge 看下bridge网络的配置信息，可以看到bridge网络配置的subnet、网关等信息。</p><h3 id="2-自定义网络"><a href="#2-自定义网络" class="headerlink" title="2.自定义网络"></a>2.自定义网络</h3><p>除了上述三种docker自动创建的网络，用户也可以根据业务需求自定义网络。docker提供三种user-defined网络驱动：bridge、overlay、macvlan。overlay与 macvlan用于创建跨主机网络。<br>通过创建bridge驱动来创建bridge网络，ip网段由docker0自动分配，例如：</p><pre><code># docker network create --driver bridge my_net1</code></pre><p>也可以通过--subnet 和--gateway 自己指定Ip网段：</p><pre><code># docker network create --driver bridge --subnet 172.18.22.0/24 --gateway 172.18.22.1 my_net2</code></pre><p>使用自定义的网络也是通过--network 指定，容器中的ip 既可以自动分配也可以在启动容器的时候使用 --ip 指定ip。</p><pre><code># docker run -it --network=my_net2 --ip 172.18.22.8 busybox# docker run -it --network=my_net2 centos</code></pre><p>注：只有使用--subnet 创建的网络才能指定静态ip。</p><h2 id="二、单机环境下容器之间的通信"><a href="#二、单机环境下容器之间的通信" class="headerlink" title="二、单机环境下容器之间的通信"></a>二、单机环境下容器之间的通信</h2><p>我们可以想到，挂在同一个bridge上的容器网段和网关都相同，肯定是可以互通的，比如使用上述的my_net2网络的两个容器busybox和centos应该是互通的，事实上也是如此。但是分别使用my_net1和my_net2的两个不同网段的容器能通吗？，答案当然是不行！那么怎么才能让他们互通呢？打开路由转发，加一条路由？这样按理来说应该是可以的，但是事实上加了路由，打开路由转发也不通。这就是docker不同网络的隔离性。docker在iptables上drop了两个网桥之间的双向流向。那么到底怎么样两个不同网段的容器才能通信呢？<br>只有加一块网卡了。在一个容器里加一块另一个网桥的网卡，通过这块网卡与另一个容器通信。</p><h3 id="容器之间的三种通信方式"><a href="#容器之间的三种通信方式" class="headerlink" title="容器之间的三种通信方式"></a>容器之间的三种通信方式</h3><h4 id="1-IP通信"><a href="#1-IP通信" class="headerlink" title="1.IP通信"></a>1.IP通信</h4><p>如上所说，在创建容器时通过--network 指定相应的网络，或者通过 docker network connect 将现有容器加入指定网络，并且都是同一个网络的网卡，这样两个容器就可以通信了。</p><h4 id="2-Docker-DNS-Server"><a href="#2-Docker-DNS-Server" class="headerlink" title="2.Docker DNS Server"></a>2.Docker DNS Server</h4><p>docker 自带 DNS服务，使容器可以直接通过“容器名”通信。</p><pre><code># docker run -it --network=my_net2 --name=bbox1 busybox# docker run -it --network=my_net2 --name=bbox2 busybox在bbox1里pingbbox2 可以通   # ping bbox2</code></pre><p>注：使用DNS 只能在 user-defined网络中使用，默认的Bridge不能使用。</p><h4 id="3-joined-容器"><a href="#3-joined-容器" class="headerlink" title="3.joined 容器"></a>3.joined 容器</h4><p>joined容器通过容器之间共享网卡和配置信息，通过127.0.0.1来直接通信。</p><pre><code># docker run -d -it --name=web1 httpd# docker run -it --network=container:web1 busybox这样两个容器内的网卡mac与ip完全一样，busybox可以直接使用127.0.0.1访问web1的httpd服务。</code></pre><p>这种通信方式适合以下场景：<br>    1）.不同容器中的应用程序希望高效快速的通信，比如web server与app server。<br>    2）.希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</p><h2 id="三、容器与外网的通信"><a href="#三、容器与外网的通信" class="headerlink" title="三、容器与外网的通信"></a>三、容器与外网的通信</h2><p>容器与外网的通信其实与其他环境与外网的通信一样的，通过 NAT 访问外网，通过 端口映射 使外网访问容器。</p><h4 id="1-容器访问外网"><a href="#1-容器访问外网" class="headerlink" title="1.容器访问外网"></a>1.容器访问外网</h4><p>主机可以访问外网的情况下，使用默认bridge网络的容器默认也能通外网，关键我们理解下通外网的本职：<br>通过 # iptables -t nat -S 可以看到：<br>当使用docker0 这个网桥的bridge网络的容器，向外Ping的时候，docker0收到容器网段的外出包，把它给masquerade处理，而MASQUERADE将包的源地址转换成host的地址发送出去，即做一次网络地址转发。</p><h4 id="2-外网访问容器"><a href="#2-外网访问容器" class="headerlink" title="2.外网访问容器"></a>2.外网访问容器</h4><p>docker 可将容器对外提供服务的端口映射到 host 的某个端口，外网通过该端口访问容器。容器启动时通过-p参数映射端口：</p><pre><code># docker run -d -p 80 httpd</code></pre><p>容器启动后，可通过 docker ps 或者 docker port 查看到 host 映射的端口。在上面的例子中，httpd 容器的 80 端口被映射到 host 32773 上，这样就可以通过 <host ip="">:<32773> 访问容器的 web 服务了。<br>除了映射动态端口，也可在-p 中指定映射到 host 某个特定端口，例如可将 80 端口映射到 host 的 8080 端口：<br>docker run -d -p 8080:80 httpd</32773></host></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、docker单机环境的下的网络&quot;&gt;&lt;a href=&quot;#一、docker单机环境的下的网络&quot; class=&quot;headerlink&quot; title=&quot;一、docker单机环境的下的网络&quot;&gt;&lt;/a&gt;一、docker单机环境的下的网络&lt;/h2&gt;&lt;h3 id=&quot;1-三种原
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记（二）</title>
    <link href="http://yoursite.com/2018/01/20/docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/20/docker基础（二）/</id>
    <published>2018-01-20T07:48:57.000Z</published>
    <updated>2018-01-20T09:38:34.500Z</updated>
    
    <content type="html"><![CDATA[<p>docker底层最重要的两种技术分别是cgroup和namespace,cgroup实现资源限额，namespace实现资源隔离。cgroup可以设置进程使用cpu、内存和io资源的限额，而namespace使得每个容器都觉得自己在独立的使用主机资源，所以实现了容器间资源的隔离。linux的六种namespace对应六种资源：mount、UTS、IPC、PID、Network和User。<br>    而cgroup对资源限额的使用主要体现在以下方面</p><h4 id="1-对内存的限额。"><a href="#1-对内存的限额。" class="headerlink" title="1.对内存的限额。"></a>1.对内存的限额。</h4><p>与操作系统类似，容器使用的内存包括物理内存和swap两种。<br>  -m 或 –memory   设置内存的使用限额<br>  –memory-swap    设置内存+swap的使用限额<br>    如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># docker run -m 200M --memory-swap=300M centos</span></span><br><span class="line">表示运行centos容器，允许该容器使用内存最多200M，swap最多100M。</span><br><span class="line">默认情况这两组参数为-1，即不限额。如果启动容器的时候只指定 -m 而不指定 --memory-swap，那么默认 --memory-swap为-m的两倍，</span><br></pre></td></tr></table></figure></p><h4 id="2-对cpu的限额"><a href="#2-对cpu的限额" class="headerlink" title="2.对cpu的限额"></a>2.对cpu的限额</h4><p>默认情况，所有容器平等使用host的cpu资源没有限制。<br>-c 或 –cpu-share 可以设置容器使用cpu的权重。不指定的话默认值为1024,也就是说 -c 参数并不能为容器设置cpu的绝对使用资源<br>某个容器最终获取到的cpu资源由它占所有容器使用cpu综合的比例决定，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动两个容器：</span><br><span class="line">   <span class="comment"># docker run --name "container1" -c 1024 centos</span></span><br><span class="line">       <span class="comment"># docker run --name "container2" -c 512 centos</span></span><br><span class="line">表明 container1容器可以得到2倍的container2容器的cpu资源。这只是在cpu资源紧张的时候，如果container1是关闭状态，</span><br><span class="line">container2依然可以使用全部的cpu资源</span><br></pre></td></tr></table></figure></p><p>–cpu 可以设置cpu工作线程的数量，最大为host物理cpu个数。<br>可以使用 progrium/stress 镜像来学习如何为容器分配内存和cpu。该镜像也可用于对容器执行压力测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run --name container1 -it -c 1024 progrium/stress --cpu 1</span></span><br></pre></td></tr></table></figure></p><h4 id="3-对block-IO的限额"><a href="#3-对block-IO的限额" class="headerlink" title="3.对block IO的限额"></a>3.对block IO的限额</h4><p>Block IO 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽。<br>默认情况下，所有容器能平等地读写磁盘，可以通过设置 –blkio-weight 参数来改变容器 block IO 的优先级。–blkio-weight<br>与 –cpu-shares 类似，设置的是相对权重值，默认为 500。<br>限制 bps 和 iops：<br>    bps 是 byte per second，每秒读写的数据量。<br>    iops 是 io per second，每秒 IO 的次数。<br>    可通过以下参数控制容器的 bps 和 iops：<br>        –device-read-bps，限制读某个设备的 bps。<br>        –device-write-bps，限制写某个设备的 bps。<br>        –device-read-iops，限制读某个设备的 iops。<br>        –device-write-iops，限制写某个设备的 iops。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -it--device-write-bps /dev/sda:30MB centos</span></span><br><span class="line">   表明限制容器写 /dev/sda 的速率为 30 MB/s，可以通过dd测试。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;docker底层最重要的两种技术分别是cgroup和namespace,cgroup实现资源限额，namespace实现资源隔离。cgroup可以设置进程使用cpu、内存和io资源的限额，而namespace使得每个容器都觉得自己在独立的使用主机资源，所以实现了容器间资源的
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记(一)</title>
    <link href="http://yoursite.com/2018/01/19/docker%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/01/19/docker基础(一)/</id>
    <published>2018-01-19T07:41:42.000Z</published>
    <updated>2018-01-22T06:14:07.756Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个月乱七八糟的学习了很多docker的东西，零散繁杂，不经常用就会遗忘很多。加之，pass层的火热，kubernetes在容器编排方面看似已经无人能敌了，所以整理以下，作为技术储备，哈哈。</p><h3 id="安装docker-ce"><a href="#安装docker-ce" class="headerlink" title="安装docker-ce"></a>安装docker-ce</h3><p>安装基础包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install epel-release -y</span></span><br><span class="line"><span class="comment"># yum install axel vim git curl wget lrzsz gcc  python-devel yum* python-pip</span></span><br></pre></td></tr></table></figure></p><p>设置docker官方repo，安装docker CE版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure></p><p>系统默认应该没有yum-config-manager,如果没有那就安装它 : yum -y install yum-utils<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y docker-ce</span></span><br><span class="line">   <span class="comment"># docker --version</span></span><br></pre></td></tr></table></figure></p><p>配置docker<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir /etc/systemd/system/docker.service.d</span></span><br><span class="line"><span class="comment"># tee /etc/systemd/system/docker.service.d/docker.conf &lt;&lt; 'EOF'</span></span><br><span class="line">[Service]</span><br><span class="line">MountFlags=shared</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>编辑 /usr/lib/systemd/system/docker.service<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ExecStart=/usr/bin/dockerd</span></span><br><span class="line">ExecStart=/usr/bin/dockerd --insecure-registry 192.168.19.133:4000</span><br></pre></td></tr></table></figure></p><p>启动docker<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl daemon-reload</span></span><br><span class="line"><span class="comment"># systemctl restart docker</span></span><br><span class="line"><span class="comment"># systemctl enable docker</span></span><br><span class="line"><span class="comment"># docker info</span></span><br></pre></td></tr></table></figure></p><p>搭建私有仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 \</span></span><br><span class="line">--restart=always --name registry registry:2</span><br></pre></td></tr></table></figure></p><h3 id="docker容器的几点特别的地方"><a href="#docker容器的几点特别的地方" class="headerlink" title="docker容器的几点特别的地方"></a>docker容器的几点特别的地方</h3><p>我们都知道docker容器是轻量级的，那么体现在哪些地方呢？<br>1.docker容器与host共用kernel,也就是说docker容器里是没有kernel空间的，只有rootfs，也就是我们常见的/dev、/usr、/bin这类东西，所以容器里是不能升级kernel的。<br>2.镜像的分层结构。绝大部分的docker镜像都是从base镜像中配置安装所需软件而来的，每配置安装一个软件，就在现有的镜像基础上增加一层，新镜像就是从base镜像一层一层叠加而来,而且每一层都是共享的，这样内存中只需存一份base镜像就可以了。当用某个镜像启动一个容器的时候，就会在镜像层之上生成一个容器层，所有对容器的操作都是在容器层，而不会对镜像层有任何改变。所以，镜像可以被多个容器共享。</p><h3 id="容器的一些常用操作"><a href="#容器的一些常用操作" class="headerlink" title="容器的一些常用操作"></a>容器的一些常用操作</h3><p>运行容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -it 镜像 /bin/bash            以交互模式启动并进入一个容器</span></span><br><span class="line">   参数：</span><br><span class="line">   -d  以后台方式启动容器</span><br><span class="line">   --name 给启动的容器命名</span><br></pre></td></tr></table></figure></p><p>进入容器的两种方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker attach 长id</span></span><br><span class="line"><span class="comment"># docker exec -it 容器名/长id/短id bash</span></span><br></pre></td></tr></table></figure></p><p>attach 与 exec 主要区别如下:<br>    1.attach 直接进入容器 启动命令 的终端，不会启动新的进程。<br>    2.exec 则是在容器中打开新的终端，并且可以启动新的进程。<br>    如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。当然，如果只是为了查看启动命令的输出，可以用 docker logs 命令</p><p>容器的常用操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker stop/start/restart 容器</span></span><br><span class="line">   <span class="comment"># docker pause/unpause 容器</span></span><br><span class="line">   <span class="comment"># docker rm 容器</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近几个月乱七八糟的学习了很多docker的东西，零散繁杂，不经常用就会遗忘很多。加之，pass层的火热，kubernetes在容器编排方面看似已经无人能敌了，所以整理以下，作为技术储备，哈哈。&lt;/p&gt;
&lt;h3 id=&quot;安装docker-ce&quot;&gt;&lt;a href=&quot;#安装do
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>kolla部署openstack的pika版</title>
    <link href="http://yoursite.com/2018/01/18/kolla%E9%83%A8%E7%BD%B2openstack%E7%9A%84pika%E7%89%88/"/>
    <id>http://yoursite.com/2018/01/18/kolla部署openstack的pika版/</id>
    <published>2018-01-18T08:44:28.000Z</published>
    <updated>2018-01-18T09:33:22.162Z</updated>
    
    <content type="html"><![CDATA[<p>用kolla部署openstack真的是超级方便简单，想当年初识openstack的时候我可是用了两周多的时间才搭建起一套没有HA的环境，可今天下午，如果不算下载docker镜像的时间，我只用不到两小时的时间就部署起一套openstack+ceph的高可用融合型环境。kolla本身将openstack包括ceph的所用服务都容器化，所有你要启动某个服务，只需要重启该服务的容器就好了。而且kolla是唯一一个没有任何厂商背景的部署工具，完全开源，已经非常成熟了，我所在公司九州云，已经部署了n多的生产案例了，扩容按理来说应该也是比较方便的。<br>贴上同事整理的部署文档，你只需要仔细一点，按照此方法应该都是可以部署成功的，所以就不多说了。<br><a href="https://www.lijiawang.org/posts/kolla-pike-on-centos.html" target="_blank" rel="noopener">https://www.lijiawang.org/posts/kolla-pike-on-centos.html</a></p><h5 id="关于网络"><a href="#关于网络" class="headerlink" title="关于网络"></a>关于网络</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kolla定义网络是在/etc/kolla/global.yml文件中,只需在相关网络的后面写上实际的物理网卡名字就可以了，如下：</span><br><span class="line">network_interface: <span class="string">"eno16777736"</span>   管理网</span><br><span class="line">api_interface: <span class="string">"&#123;&#123; network_interface &#125;&#125;"</span></span><br><span class="line">storage_interface: <span class="string">"&#123;&#123; network_interface &#125;&#125;"</span>   存储网</span><br><span class="line">cluster_interface: <span class="string">"&#123;&#123; network_interface &#125;&#125;"</span>   存储集群网</span><br><span class="line">tunnel_interface: <span class="string">"&#123;&#123; network_interface &#125;&#125;"</span>    </span><br><span class="line">dns_interface: <span class="string">"&#123;&#123; network_interface &#125;&#125;"</span>       vxlan网</span><br><span class="line">neutron_external_interface: <span class="string">"eno33554960"</span>      private网</span><br><span class="line">网络可以分离，也可以用同一块，但是最少应该两块网卡，因为private网络需要独立。如果你做了网卡绑定的话，就换成bond0或bond1等</span><br></pre></td></tr></table></figure><h5 id="关于节点信息"><a href="#关于节点信息" class="headerlink" title="关于节点信息"></a>关于节点信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关于节点的定义信息是在multinode文件中，在此文件中你可以用hostname来定义哪些物理机是control,哪些是compute，哪些是storage，</span><br><span class="line">哪些是network等等，你可以定义openstack的服务安装在哪些节点上。如下：</span><br><span class="line">[control]</span><br><span class="line">control01</span><br><span class="line">control02</span><br><span class="line">control03</span><br><span class="line">表示control01、control02、control03是控制节点，control01、control02、control03是三个节点的hostname。</span><br><span class="line">[keystone:children]</span><br><span class="line">control</span><br><span class="line">表示keystone服务安装在所有的control节点</span><br></pre></td></tr></table></figure><h5 id="关于要安装哪些组件"><a href="#关于要安装哪些组件" class="headerlink" title="关于要安装哪些组件"></a>关于要安装哪些组件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这个功能也在global.yml文件中定义，如下：</span><br><span class="line">enable_barbican: <span class="string">"no"</span></span><br><span class="line">enable_ceilometer: <span class="string">"yes"</span></span><br><span class="line">enable_central_logging: <span class="string">"yes"</span></span><br><span class="line">enable_ceph: <span class="string">"yes"</span></span><br><span class="line">enable_ceph_rgw: <span class="string">"yes"</span></span><br><span class="line">enable_chrony: <span class="string">"yes"</span></span><br><span class="line">enable_cinder: <span class="string">"yes"</span></span><br><span class="line">enable_cinder_backend_hnas_iscsi: <span class="string">"no"</span></span><br><span class="line">enable_cinder_backend_hnas_nfs: <span class="string">"no"</span></span><br><span class="line">enable_cinder_backend_iscsi: <span class="string">"no"</span></span><br><span class="line">enable_cinder_backend_lvm: <span class="string">"no"</span></span><br><span class="line">enable_cinder_backend_nfs: <span class="string">"no"</span></span><br><span class="line">如果你想安装哪个组件，只需要将该组件行的注释去掉，冒号里写yes即可</span><br></pre></td></tr></table></figure><p>当这些都定义完就可以deploy了，你可以在deploy之前先prechecks下，防止一些语法错误。<br>再多说一点，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在你已经部署完成的情况下，如果要更改global.yml文件，改完以后执行以下命令：</span><br><span class="line">kolla-ansible upgrade -i multinode</span><br><span class="line">kolla-ansible post-deploy -i multinode</span><br><span class="line">如果修改了/etc/config/[server]/[server].conf文件：</span><br><span class="line">kolla-ansible reconfigure -i multinode</span><br><span class="line">如果部署失败，可以清除然后重新部署，清除的命令是：</span><br><span class="line">kolla-ansible destroy -i multinode --yes-i-really-really-mean-it</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用kolla部署openstack真的是超级方便简单，想当年初识openstack的时候我可是用了两周多的时间才搭建起一套没有HA的环境，可今天下午，如果不算下载docker镜像的时间，我只用不到两小时的时间就部署起一套openstack+ceph的高可用融合型环境。kol
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="openstack" scheme="http://yoursite.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>Linux字符管理命令</title>
    <link href="http://yoursite.com/2018/01/09/Linux%E5%AD%97%E7%AC%A6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/09/Linux字符管理命令/</id>
    <published>2018-01-09T04:23:18.000Z</published>
    <updated>2018-01-13T12:48:43.335Z</updated>
    
    <content type="html"><![CDATA[<p>平时工作中经常用到grep、awk、sort、sed等字符管理命令，但是自己记性又不好，每次需要去google，索性总结一下，方便以后查询。</p><h2 id="cut-截取所需字符"><a href="#cut-截取所需字符" class="headerlink" title="cut 截取所需字符"></a>cut 截取所需字符</h2><p>-d “n”:定义分界符,即点位<br>-f n:取第几位的字符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：以空格符为分界符,进行第2位截取 </span><br><span class="line">　　　cut -d <span class="string">" "</span> -f 2 /etc/fstab</span><br><span class="line">　　　　以冒号为分界符，进行第1，3位截取</span><br><span class="line">　　　cut -d <span class="string">":"</span> -f 1,3 /etc/passwd</span><br></pre></td></tr></table></figure></p><h2 id="sed-通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作"><a href="#sed-通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作" class="headerlink" title="sed 通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作"></a>sed 通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作</h2><p>1.关于替换：<br>　　1).sed替换的基本语法为: sed ‘s/原字符串/替换字符串/‘ filename<br>　　s 表示替换 特殊字符需要使用反斜线“\”进行转义，单引号是不能用反斜线转义，要用反斜线的话使用双引号。<br>　　要处理的字符串包含单引号也用双引号。<br>　　注意：在末尾加g替换每一个匹配的关键字，否则只替换每一行的第一个字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">替换所有匹配关键字</span><br><span class="line">　　　sed <span class="string">'s/原字符串/替换字符串/g'</span> filename</span><br></pre></td></tr></table></figure></p><p>　　2）三根斜线也可换成别的符号，只要紧跟s定义即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将分隔符换成问号”?”:</span><br><span class="line">　　　　sed <span class="string">'s?原字符串?替换字符串?'</span></span><br></pre></td></tr></table></figure></p><p>　　注意：sed处理过的输出是直接输出到屏幕上的,使用参数”i”直接在文件中替换<br>　　3）多个替换可以在同一条命令中执行,用分号”;”分隔，其格式为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同时执行两个替换规则</span><br><span class="line">　　　　　sed <span class="string">'s/^/添加的头部&amp;/g；s/$/&amp;添加的尾部/g'</span></span><br></pre></td></tr></table></figure></p><p>　　4）一些特殊字符的使用<br>　　　　”^”表示行首<br>　　 ”$”符号如果在引号中表示行尾，但是在引号外却表示末行(最后一行)<br>2.关于删除：<br>　　1）d 删除指定行,要在文件内删除，同样加参数i<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除文件的第1-3行 </span><br><span class="line">　　　　sed <span class="string">'1,3d'</span> filename</span><br><span class="line">　　删除文件的第3行到最后一行</span><br><span class="line">　　　　sed ‘3,<span class="variable">$d</span>’ filename</span><br><span class="line">　　删除含有指定字段的行</span><br><span class="line">　　　　sed <span class="string">'/字符/d'</span> filename</span><br></pre></td></tr></table></figure></p><p>   3)多点编辑<br>　　使用-e参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除第1-3行，替换某字符</span><br><span class="line">　　　　sed -e <span class="string">'1,3d'</span> -e <span class="string">'s/原字符/替换的字符/'</span> filename</span><br></pre></td></tr></table></figure></p><p>4)文件操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将含有某字段的行写入新的文件中</span><br><span class="line">　　sed -n <span class="string">'/某字段/w 新文件'</span> filename</span><br><span class="line">　　将小写改为大写</span><br><span class="line">　　sed <span class="string">'y/小写字母/大写字母/'</span> filename</span><br></pre></td></tr></table></figure></p><h2 id="awk-通过正则表达式-得到需要的行-列信息"><a href="#awk-通过正则表达式-得到需要的行-列信息" class="headerlink" title="awk 通过正则表达式,得到需要的行,列信息"></a>awk 通过正则表达式,得到需要的行,列信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　查看df -h命令的第2列</span><br><span class="line">　　　　df -h | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">　　查看df -h命令的第2,5列</span><br><span class="line">　　　　df -h | awk <span class="string">'&#123;print $2,$5&#125;'</span></span><br><span class="line">　　列示月份及年份(\n为换行符)</span><br><span class="line">　　　　date | awk <span class="string">'&#123;print "Year:" $6 "\nMonth:" $2&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="sort-默认以排序ASCII方式进行排序-a-z"><a href="#sort-默认以排序ASCII方式进行排序-a-z" class="headerlink" title="sort 默认以排序ASCII方式进行排序[a-z]"></a>sort 默认以排序ASCII方式进行排序[a-z]</h2><p>　　参数:<br>　　-u 去除重复的行<br>　　-r 降序排序[z-a]<br>　　-n 数值排序,默认情况10比2小,主要因为sort判断第一字符的值<br>　　-k 以文本的列进行判断<br>　　-t 设定分界符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　 对/etc/passwd文件进行升序排序</span><br><span class="line">　　　　sort /etc/passwd</span><br><span class="line">　　对/etc/passwd文件进行降序排序</span><br><span class="line">　　　　sort -r /etc/passwd</span><br><span class="line">　　对/etc/passwd第3列进行数值排序,分界符为:</span><br><span class="line">　　　　sort -n -k 3 -t : /etc/passwd</span><br></pre></td></tr></table></figure></p><h2 id="wc-统计行数、字数、字符数、文件总统计数"><a href="#wc-统计行数、字数、字符数、文件总统计数" class="headerlink" title="wc 统计行数、字数、字符数、文件总统计数"></a>wc 统计行数、字数、字符数、文件总统计数</h2><p>　　参数:<br>　　-l 统计行数<br>　　-c 统计字节数<br>　　-w 统计字数(单词数<br>　　uniq 检查文本中重复出现的行<br>　　-c 显示输出,并在文本行前加出现的次数,但如果<br>　　重复行不连续，则不认为是重复的行<br>　　-d 只显示重复的行<br>　　-u 只显示不重复的行<br>　　-f n前N个字段和每个字段前的空白行一起被忽略,字段从0开始编号<br>　　-s n 前N个字符被忽略,字符从0开始编号<br>　　-w n 对N个字符以后的字符不在检查重复性</p><h2 id="tee-读取标准输入的数据，并将其内容输出成文件"><a href="#tee-读取标准输入的数据，并将其内容输出成文件" class="headerlink" title="tee 读取标准输入的数据，并将其内容输出成文件"></a>tee 读取标准输入的数据，并将其内容输出成文件</h2><p>　　说明:指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件<br>　　参数:<br>　　-a:附加到既有文件的后面，而非覆盖它．<br>　　-i:忽略中断信号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　 查询当前账户并写入who.txt文件中</span><br><span class="line">who | tee who.txt</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时工作中经常用到grep、awk、sort、sed等字符管理命令，但是自己记性又不好，每次需要去google，索性总结一下，方便以后查询。&lt;/p&gt;
&lt;h2 id=&quot;cut-截取所需字符&quot;&gt;&lt;a href=&quot;#cut-截取所需字符&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>

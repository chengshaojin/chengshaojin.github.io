<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shaojin&#39;s Words</title>
  
  <subtitle>如果有一天有人问你，你觉得我这个人怎么样，你能略加思考的说他是一个有趣的人，那么我就会很开心!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-14T07:45:50.820Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>程少进</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>openstack虚拟机网络流向详解</title>
    <link href="http://yoursite.com/2018/01/14/openstack%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/14/openstack虚拟机网络流向详解/</id>
    <published>2018-01-14T05:32:04.000Z</published>
    <updated>2018-01-14T07:45:50.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="openstack网络组件"><a href="#openstack网络组件" class="headerlink" title="openstack网络组件"></a>openstack网络组件</h2><h4 id="1-网络节点组件"><a href="#1-网络节点组件" class="headerlink" title="1.网络节点组件"></a>1.网络节点组件</h4><p><img src="./网络节点组件.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.DHCP agent(namespace,dnsmasq)，用于创建和管理DHCP Server,每个虚拟网络都有一个DHCP Server，为这个网络里的虚拟机提供ip,当然你也可以关掉DHCP。</span><br><span class="line">2.Metadata agent(namespace,metadata进程，cloud-init)。Instance在启动时需要访问nova-metadata-api来获取instance的一些信息，比如hostname、ip、public key等，但是Instance启动时并没有ip，此时就是metadata-agent来使instance通过dhcp-agent或l3-agent与nova-metadata-api通信。</span><br><span class="line">3.L3 agent(namespace,iptables),用于创建和管理虚拟路由器，可以在router上配置防火墙策略。</span><br></pre></td></tr></table></figure></p><h4 id="2-计算节点组件"><a href="#2-计算节点组件" class="headerlink" title="2.计算节点组件"></a>2.计算节点组件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.OpenvSwitch agent</span><br><span class="line">2.Linux Bridge</span><br><span class="line">由于OVS不能直接操作iptables来实现安全组，所以老版本比如L版在VM和OVS中间添加了LinuxBridge来实现安全组。O版提供native openvswitch firewall driver可以不需要LinuxBridge</span><br></pre></td></tr></table></figure><h2 id="网络通信场景"><a href="#网络通信场景" class="headerlink" title="网络通信场景"></a>网络通信场景</h2><h4 id="1-区域内VM东西向通信（instance之间网络流向）"><a href="#1-区域内VM东西向通信（instance之间网络流向）" class="headerlink" title="1.区域内VM东西向通信（instance之间网络流向）"></a>1.区域内VM东西向通信（instance之间网络流向）</h4><ul><li><h5 id="同网段"><a href="#同网段" class="headerlink" title="同网段"></a>同网段</h5><img src="./text.png" alt="alt text"><h6 id="节点1上的instance1向节点2上的instance2发送报文，报文在节点1上会经过以下步骤："><a href="#节点1上的instance1向节点2上的instance2发送报文，报文在节点1上会经过以下步骤：" class="headerlink" title="节点1上的instance1向节点2上的instance2发送报文，报文在节点1上会经过以下步骤："></a>节点1上的instance1向节点2上的instance2发送报文，报文在节点1上会经过以下步骤：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1).Instance 1的接口（1）通过veth pair将报文转发到linux bridge端口（2）。</span><br><span class="line">2)安全组规则（3）在linux bridge上处理报文的过滤。</span><br><span class="line">3)Linux bridge连接OVS的端口（4）通过veth pair将报文转发到OVS br-int连接linux bridge的端口（5）</span><br><span class="line">4)OVS br-int为报文添加一个内部VLAN tag。</span><br><span class="line">5)OVS br-int将内部VLAN tag转换为内部隧道ID。</span><br><span class="line">6)OVS br-int通过patch端口（6）将报文转发到OVS br-tun patch端口（7）。</span><br><span class="line">7)OVS br-tun（8）使用VNI 101封装数据包</span><br><span class="line">8)Overlay网络的物理网卡（9）通过overlay网络（10）将报文转发到计算节点2。</span><br></pre></td></tr></table></figure></li></ul><h6 id="报文在节点2上经过以下步骤："><a href="#报文在节点2上经过以下步骤：" class="headerlink" title="报文在节点2上经过以下步骤："></a>报文在节点2上经过以下步骤：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）Overlay网络的物理网卡（11）将报文转发到OVS br-tun（12）。</span><br><span class="line">2）OVS br-tun解封装报文并添加一个内部隧道ID。</span><br><span class="line">3）OVS br-tun将内部隧道ID转换为内部VLAN tag。</span><br><span class="line">4）OVS br-tun patch端口（13）将报文转发到OVS br-int patch丁端口（14）。</span><br><span class="line">5）OVS br-int从报文中删除内部VLAN标记</span><br><span class="line">6）OVS br-int 连接linux bridge的端口（15）通过veth pair将报文转发到linux bridge连接OVS的端口（16）。</span><br><span class="line">7）安全组规则（17）在linux bridge上处理报文的过滤。</span><br><span class="line">8）Linux bridge端口（18）通过veth pair将报文转发到instance 2的接口（19）</span><br></pre></td></tr></table></figure><ul><li><h5 id="不同网段"><a href="#不同网段" class="headerlink" title="不同网段"></a>不同网段</h5><img src="./不同网段.png" alt=""><h6 id="Instance1和instance2在同一个主机但属于不同的租户网络，报文在计算节点上经过以下步骤："><a href="#Instance1和instance2在同一个主机但属于不同的租户网络，报文在计算节点上经过以下步骤：" class="headerlink" title="Instance1和instance2在同一个主机但属于不同的租户网络，报文在计算节点上经过以下步骤："></a>Instance1和instance2在同一个主机但属于不同的租户网络，报文在计算节点上经过以下步骤：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) instance 1的接口（1）通过veth pair将报文转发到linux bridge端口（2）</span><br><span class="line">2)安全组规则（3）在linux bridge处理报文的过滤</span><br><span class="line">3）Linux bridge连接OVS的端口（4）通过veth pair将报文转发到OVS br-int连接linux bridge的端口（5）。</span><br><span class="line">4）OVS br-int为报文添加了一个内部VLAN tag。</span><br><span class="line">5）OVS br-int将内部VLAN tag转换为内部隧道ID。</span><br><span class="line">6）OVS br-int的patch端口（6）将数据包转发到OVS br-tun的patch端口（7）</span><br><span class="line">7）OVS br-tun（8）使用VNI 101封装报文</span><br><span class="line">8）Overlay网络的物理网卡（9）通过overlay网络（10）将报文转发到网络节点。</span><br></pre></td></tr></table></figure></li></ul><h6 id="报文在网络节点上经过以下步骤："><a href="#报文在网络节点上经过以下步骤：" class="headerlink" title="报文在网络节点上经过以下步骤："></a>报文在网络节点上经过以下步骤：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）Overlay网络的物理网卡（11）将报文转发到OVS br-tun（12）。</span><br><span class="line">2）OVS br-tun解封装报文并添加一个内部隧道ID。</span><br><span class="line">3）OVS br-tun将内部隧道ID转换为内部VLAN tag。</span><br><span class="line">4）OVS br-tun的patch端口（13）将报文转发到OVS br-int的patch端口（14）。</span><br><span class="line">5）用于租户网络1的OVS br-int端口（15）去除内部VLAN tag，并将该报文转发到router namespace中的租户网络1接口（16）。</span><br><span class="line">6）router通过租户网络2接口（17）将报文发送到下一跳IP地址，即租户网络2上的网关IP地址。</span><br><span class="line">7）router将报文转发到租户网络2的OVS br-int端口（18）</span><br><span class="line">后续的报文从router到instance 2的步骤原路返回。</span><br></pre></td></tr></table></figure><h4 id="2-VM南北向通信（instance通过router访问外部网络）"><a href="#2-VM南北向通信（instance通过router访问外部网络）" class="headerlink" title="2.VM南北向通信（instance通过router访问外部网络）"></a>2.VM南北向通信（instance通过router访问外部网络）</h4><p><img src="./南北流向.png" alt=""></p><h6 id="instance通过router访问外部网络时，报文在计算节点经过以下步骤："><a href="#instance通过router访问外部网络时，报文在计算节点经过以下步骤：" class="headerlink" title="instance通过router访问外部网络时，报文在计算节点经过以下步骤："></a>instance通过router访问外部网络时，报文在计算节点经过以下步骤：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）Instance接口（1）通过veth pair将报文转发到linux bridge端口（2）。</span><br><span class="line">2）安全组规则（3）在linux bridge处理报文的过滤。</span><br><span class="line">3）Linux bridge连接OVS的端口（4）通过veth pair将报文转发到OVS连接linux bridge的端口（5）。</span><br><span class="line">4）OVS br-int为报文添加了一个内部VLAN tag。</span><br><span class="line">5）OVS br-int将内部VLANtag转换为内部隧道ID。</span><br><span class="line">6）OVS br-int的patch端口（6）将报文转发到OVS br-tun的patch端口（7）。</span><br><span class="line">7）OVS br-tun（8）使用VNI 101封装报文。</span><br><span class="line">8）Overlay网络的物理网卡（9）通过overlay网络（10）将报文转发到网络节点。</span><br></pre></td></tr></table></figure><h6 id="报文在网络节点经过以下步骤："><a href="#报文在网络节点经过以下步骤：" class="headerlink" title="报文在网络节点经过以下步骤："></a>报文在网络节点经过以下步骤：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）Overlay网络的物理网卡（11）将报文转发到OVS br-tun（12）。</span><br><span class="line">2）OVS br-tun解封装报文并添加一个内部隧道ID。</span><br><span class="line">3）OVS br-tun将内部隧道ID转换为内部VLAN tag。</span><br><span class="line">4）OVS br-tun的patch端口（13）将分组转发到OVS br-int的patch端口（14）。</span><br><span class="line">5）用于租户网络的OVS br-int端口（15）去除内部VLAN tag，并将报文转发到router namespace中的租户网络接口（16）。</span><br><span class="line">6）router将报文转发给provider网络的OVS br-int端口（18）。</span><br><span class="line">7）OVS br-int将内部VLAN tag添加到报文。</span><br><span class="line">8）OVS br-int的patch端口（19）将报文转发给OVS br-provider的patch端口（20）。</span><br><span class="line">9）OVS br-provider将内部VLAN tag转换为实际的VLAN tag 101。</span><br><span class="line">10）OVS br-provider的端口（21）将报文转发给物理网络接口（22）。</span><br><span class="line">11）物理网络接口通过物理网络将报文转发到因特网（23）。</span><br></pre></td></tr></table></figure><h2 id="常见故障现象和排除方法"><a href="#常见故障现象和排除方法" class="headerlink" title="常见故障现象和排除方法"></a>常见故障现象和排除方法</h2><h4 id="1-DHCP请求失败"><a href="#1-DHCP请求失败" class="headerlink" title="1.DHCP请求失败"></a>1.DHCP请求失败</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1).neutron agent-list 检查dhcp agent服务状态</span><br><span class="line">2).ip netns <span class="built_in">exec</span> qdhcp-xxxxxxxxxxxx bash进入namespace，查看dnsmasq进程是否运行中   ps aux | grep dns</span><br><span class="line">3).进入namespace tcpdump抓包查看dhcp接口是否收到dhcp请求，如果没有收到，说明二层网络不通。</span><br><span class="line">4).结合虚拟机通信数据流图依次在流量路径上用tcpdump抓包，判断网络连接不通的原因。</span><br></pre></td></tr></table></figure><h4 id="2-Metadata获取失败"><a href="#2-Metadata获取失败" class="headerlink" title="2.Metadata获取失败"></a>2.Metadata获取失败</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1).neutron agent-list 检查metadata agent服务状态</span><br><span class="line">2).对于没有连接到router的网络，需要配置enable_isolated_metadata = <span class="literal">true</span>后metadata服务才会生效，配置的效果是会在dhcp namespace中启动metadata相关进程。</span><br><span class="line">3).虚拟机本身需要已经安装并<span class="built_in">enable</span> cloud-init服务才会在启动时获取metadata。</span><br><span class="line">4).如果已经拿到DHCP信息，基本可以排除网络的原因，主要检查服务的状态。</span><br></pre></td></tr></table></figure><h4 id="3-Arp请求失败"><a href="#3-Arp请求失败" class="headerlink" title="3.Arp请求失败"></a>3.Arp请求失败</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1).网络通信首先需要发送ARP请求获取MAC地址，网络不通时可以使用arp –a查看本地ARP缓存。</span><br><span class="line">2).如果无法通过ARP请求获取目标IP或网关IP的MAC地址，说明二层网络不通。</span><br><span class="line">3).结合虚拟机通信数据流图依次在流量路径上用tcpdump抓包，判断网络连接不通的原因。</span><br></pre></td></tr></table></figure><h4 id="4-Arp请求成功，IP通信失败"><a href="#4-Arp请求成功，IP通信失败" class="headerlink" title="4.Arp请求成功，IP通信失败"></a>4.Arp请求成功，IP通信失败</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1).使用arp –a查看本地ARP缓存，如果已经获取到了目标地址的MAC地址，说明源和目的之间的二层网络正常，可以检查路径上的安全组或防火墙的配置，检查是否允许使用的协议通过。</span><br><span class="line">2).Neutron的安全组默认只允许报文以端口的IP和MAC地址向外发送报文，如果有需要（比如虚拟机的服务创建了新的IP或MAC地址），可以关闭端口的安全组功能：</span><br><span class="line">        neutron port-update --no-security-groups <span class="variable">$port_id</span></span><br><span class="line">         neutron port-update <span class="variable">$port_id</span> --port-security-enabled=False</span><br></pre></td></tr></table></figure><h4 id="5-OVS和Openflow相关操作"><a href="#5-OVS和Openflow相关操作" class="headerlink" title="5.OVS和Openflow相关操作"></a>5.OVS和Openflow相关操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1).如果以上的网络检查做完还是无法解决问题，可以通过OVS的命令检查OVS和Openflow流表的状态。</span><br><span class="line">ovs-vsctl show查看OVS的bridge和port的信息。</span><br><span class="line">ovs-ofctl dump-flows &#123;BRIDGE_NAME&#125;查看bridge中的Openflow流表的情况。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;openstack网络组件&quot;&gt;&lt;a href=&quot;#openstack网络组件&quot; class=&quot;headerlink&quot; title=&quot;openstack网络组件&quot;&gt;&lt;/a&gt;openstack网络组件&lt;/h2&gt;&lt;h4 id=&quot;1-网络节点组件&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="openstack" scheme="http://yoursite.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>Linux字符管理命令</title>
    <link href="http://yoursite.com/2018/01/09/Linux%E5%AD%97%E7%AC%A6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/09/Linux字符管理命令/</id>
    <published>2018-01-09T04:23:18.000Z</published>
    <updated>2018-01-13T12:48:43.335Z</updated>
    
    <content type="html"><![CDATA[<p>平时工作中经常用到grep、awk、sort、sed等字符管理命令，但是自己记性又不好，每次需要去google，索性总结一下，方便以后查询。</p><h2 id="cut-截取所需字符"><a href="#cut-截取所需字符" class="headerlink" title="cut 截取所需字符"></a>cut 截取所需字符</h2><p>-d “n”:定义分界符,即点位<br>-f n:取第几位的字符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：以空格符为分界符,进行第2位截取 </span><br><span class="line">　　　cut -d <span class="string">" "</span> -f 2 /etc/fstab</span><br><span class="line">　　　　以冒号为分界符，进行第1，3位截取</span><br><span class="line">　　　cut -d <span class="string">":"</span> -f 1,3 /etc/passwd</span><br></pre></td></tr></table></figure></p><h2 id="sed-通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作"><a href="#sed-通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作" class="headerlink" title="sed 通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作"></a>sed 通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作</h2><p>1.关于替换：<br>　　1).sed替换的基本语法为: sed ‘s/原字符串/替换字符串/‘ filename<br>　　s 表示替换 特殊字符需要使用反斜线“\”进行转义，单引号是不能用反斜线转义，要用反斜线的话使用双引号。<br>　　要处理的字符串包含单引号也用双引号。<br>　　注意：在末尾加g替换每一个匹配的关键字，否则只替换每一行的第一个字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">替换所有匹配关键字</span><br><span class="line">　　　sed <span class="string">'s/原字符串/替换字符串/g'</span> filename</span><br></pre></td></tr></table></figure></p><p>　　2）三根斜线也可换成别的符号，只要紧跟s定义即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将分隔符换成问号”?”:</span><br><span class="line">　　　　sed <span class="string">'s?原字符串?替换字符串?'</span></span><br></pre></td></tr></table></figure></p><p>　　注意：sed处理过的输出是直接输出到屏幕上的,使用参数”i”直接在文件中替换<br>　　3）多个替换可以在同一条命令中执行,用分号”;”分隔，其格式为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同时执行两个替换规则</span><br><span class="line">　　　　　sed <span class="string">'s/^/添加的头部&amp;/g；s/$/&amp;添加的尾部/g'</span></span><br></pre></td></tr></table></figure></p><p>　　4）一些特殊字符的使用<br>　　　　”^”表示行首<br>　　 ”$”符号如果在引号中表示行尾，但是在引号外却表示末行(最后一行)<br>2.关于删除：<br>　　1）d 删除指定行,要在文件内删除，同样加参数i<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除文件的第1-3行 </span><br><span class="line">　　　　sed <span class="string">'1,3d'</span> filename</span><br><span class="line">　　删除文件的第3行到最后一行</span><br><span class="line">　　　　sed ‘3,<span class="variable">$d</span>’ filename</span><br><span class="line">　　删除含有指定字段的行</span><br><span class="line">　　　　sed <span class="string">'/字符/d'</span> filename</span><br></pre></td></tr></table></figure></p><p>   3)多点编辑<br>　　使用-e参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除第1-3行，替换某字符</span><br><span class="line">　　　　sed -e <span class="string">'1,3d'</span> -e <span class="string">'s/原字符/替换的字符/'</span> filename</span><br></pre></td></tr></table></figure></p><p>4)文件操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将含有某字段的行写入新的文件中</span><br><span class="line">　　sed -n <span class="string">'/某字段/w 新文件'</span> filename</span><br><span class="line">　　将小写改为大写</span><br><span class="line">　　sed <span class="string">'y/小写字母/大写字母/'</span> filename</span><br></pre></td></tr></table></figure></p><h2 id="awk-通过正则表达式-得到需要的行-列信息"><a href="#awk-通过正则表达式-得到需要的行-列信息" class="headerlink" title="awk 通过正则表达式,得到需要的行,列信息"></a>awk 通过正则表达式,得到需要的行,列信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　查看df -h命令的第2列</span><br><span class="line">　　　　df -h | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">　　查看df -h命令的第2,5列</span><br><span class="line">　　　　df -h | awk <span class="string">'&#123;print $2,$5&#125;'</span></span><br><span class="line">　　列示月份及年份(\n为换行符)</span><br><span class="line">　　　　date | awk <span class="string">'&#123;print "Year:" $6 "\nMonth:" $2&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="sort-默认以排序ASCII方式进行排序-a-z"><a href="#sort-默认以排序ASCII方式进行排序-a-z" class="headerlink" title="sort 默认以排序ASCII方式进行排序[a-z]"></a>sort 默认以排序ASCII方式进行排序[a-z]</h2><p>　　参数:<br>　　-u 去除重复的行<br>　　-r 降序排序[z-a]<br>　　-n 数值排序,默认情况10比2小,主要因为sort判断第一字符的值<br>　　-k 以文本的列进行判断<br>　　-t 设定分界符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　 对/etc/passwd文件进行升序排序</span><br><span class="line">　　　　sort /etc/passwd</span><br><span class="line">　　对/etc/passwd文件进行降序排序</span><br><span class="line">　　　　sort -r /etc/passwd</span><br><span class="line">　　对/etc/passwd第3列进行数值排序,分界符为:</span><br><span class="line">　　　　sort -n -k 3 -t : /etc/passwd</span><br></pre></td></tr></table></figure></p><h2 id="wc-统计行数、字数、字符数、文件总统计数"><a href="#wc-统计行数、字数、字符数、文件总统计数" class="headerlink" title="wc 统计行数、字数、字符数、文件总统计数"></a>wc 统计行数、字数、字符数、文件总统计数</h2><p>　　参数:<br>　　-l 统计行数<br>　　-c 统计字节数<br>　　-w 统计字数(单词数<br>　　uniq 检查文本中重复出现的行<br>　　-c 显示输出,并在文本行前加出现的次数,但如果<br>　　重复行不连续，则不认为是重复的行<br>　　-d 只显示重复的行<br>　　-u 只显示不重复的行<br>　　-f n前N个字段和每个字段前的空白行一起被忽略,字段从0开始编号<br>　　-s n 前N个字符被忽略,字符从0开始编号<br>　　-w n 对N个字符以后的字符不在检查重复性</p><h2 id="tee-读取标准输入的数据，并将其内容输出成文件"><a href="#tee-读取标准输入的数据，并将其内容输出成文件" class="headerlink" title="tee 读取标准输入的数据，并将其内容输出成文件"></a>tee 读取标准输入的数据，并将其内容输出成文件</h2><p>　　说明:指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件<br>　　参数:<br>　　-a:附加到既有文件的后面，而非覆盖它．<br>　　-i:忽略中断信号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　 查询当前账户并写入who.txt文件中</span><br><span class="line">who | tee who.txt</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时工作中经常用到grep、awk、sort、sed等字符管理命令，但是自己记性又不好，每次需要去google，索性总结一下，方便以后查询。&lt;/p&gt;
&lt;h2 id=&quot;cut-截取所需字符&quot;&gt;&lt;a href=&quot;#cut-截取所需字符&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>

[{"title":"openstack queens版本multi-attach实践","date":"2018-04-11T09:22:00.000Z","path":"2018/04/11/openstack queens版本multi-attach实践/","text":"Openstack第17个版本Queens发布以来，最引人注目的莫过于cinder后端volume multiattach功能了，这个功能可以把一个volume同时挂载给多个不同的虚拟机，如果其中一个虚拟机宕了，其他的虚拟机可以接管这个卷并正常访问。该功能解决了很多客户的实际需求，是个非常实用的功能。下面我用kolla搭建一个all-in-one的queens环境，cinder后端使用lvm。 安装openstack queens1.准备环境123456[root@queens ~]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) [root@queens ~]# uname -r3.10.0-327.el7.x86_64[root@queens ~]# hostnamequeens 关闭firewall、selinux、NetworkManager查看是否开启虚拟化1[root@queens ~]# egrep \"vmx|svm\" /proc/cpuinfo 安装基础软件包12[root@queens ~]# yum install epel-release[root@queens ~]# yum install axel vim git curl wget lrzsz gcc python-devel python-pip 2.安装配置docker12# wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# yum install -y docker-ce 12345678# mkdir /etc/systemd/system/docker.service.d# tee /etc/systemd/system/docker.service.d/kolla.conf &lt;&lt; 'EOF'[Service]MountFlags=sharedEOF# vim /usr/lib/systemd/system/docker.service# ExecStart=/usr/bin/dockerdExecStart=/usr/bin/dockerd --registry-mirror=http://f2d6cb40.m.daocloud.io --storage-driver=overlay2 12345# systemctl daemon-reload# systemctl restart docker# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.# systemctl status docker 3.安装ansible1# yum -y install ansible -y 4.下载kolla-ansible,安装配置1234# git clone https://github.com/openstack/kolla-ansible -b stable/queens# cd kolla-ansible/# cp -r etc/kolla/ /etc/kolla/# pip install . -i https://pypi.tuna.tsinghua.edu.cn/simple 修改globals.yml文件1234567891011121314151617[root@queens ~]# egrep \"^[^#]\" /etc/kolla/globals.yml---kolla_install_type: \"source\"openstack_release: \"queens\"kolla_internal_vip_address: \"192.168.192.129\"docker_namespace: \"kolla\"network_interface: \"eno16777736\"neutron_external_interface: \"eno33554960\"enable_cinder: \"yes\"enable_cinder_backend_lvm: \"yes\"enable_haproxy: \"no\"cinder_volume_group: \"cinder-volumes\"nova_compute_virt_type: \"qemu\"tempest_image_id:tempest_flavor_ref_id:tempest_public_network_id:tempest_floating_network_name: 5.配置lvm12# pvcreate /dev/sdb# vgcreate cinder-volume /dev/sdb 6.安装kolla及部署openstack123456# kolla-genpwd修改/etc/kolla/passwords.yml文件# kolla-ansible prechecks# kolla-ansible pull# kolla-ansible deploy# kolla-ansible post-deploy 6.openstack环境配置1234567安装openstack client# pip install python-openstackclient修改init-runonce文件，设置创建网络的ip池加载环境变量# source /etc/kolla/admin-openrc.sh初始化# cd /usr/share/kolla-ansibale &amp;&amp; ./init-runonce multiattach实践1.创建multiattach的卷类型并设置1234567[root@queens ~]# cinder type-create multiattach+--------------------------------------+-------------+-------------+-----------+| ID | Name | Description | Is_Public |+--------------------------------------+-------------+-------------+-----------+| ea3205d6-e3a0-4dd4-974a-20fab2830bf7 | multiattach | - | True |+--------------------------------------+-------------+-------------+-----------+[root@queens ~]# cinder type-key multiattach set multiattach=\"&lt;is&gt; True\" 2.创建一个1G的volume,使用刚刚创建的卷类型1234567891011121314151617181920212223242526272829[root@queens ~]# cinder create 1 --name multiattach_volume --volume-type ea3205d6-e3a0-4dd4-974a-20fab2830bf7+--------------------------------+--------------------------------------+| Property | Value |+--------------------------------+--------------------------------------+| attachments | [] || availability_zone | nova || bootable | false || consistencygroup_id | None || created_at | 2018-04-11T09:13:57.000000 || description | None || encrypted | False || id | d93e1565-6dd2-442a-a017-f1dc5cc91d86 || metadata | &#123;&#125; || migration_status | None || multiattach | True || name | multiattach_volume || os-vol-host-attr:host | queens@lvm-1#lvm-1 || os-vol-mig-status-attr:migstat | None || os-vol-mig-status-attr:name_id | None || os-vol-tenant-attr:tenant_id | fbe246bc04a146928d8ecaf0e32d8eec || replication_status | None || size | 1 || snapshot_id | None || source_volid | None || status | creating || updated_at | 2018-04-11T09:13:57.000000 || user_id | 7593374948ec463fa09a71a24c82c69e || volume_type | multiattach |+--------------------------------+--------------------------------------+ 3.创建两个虚拟机1234567[root@queens ~]# nova list+--------------------------------------+--------+--------+------------+-------------+--------------------+| ID | Name | Status | Task State | Power State | Networks |+--------------------------------------+--------+--------+------------+-------------+--------------------+| 4203f1d1-1511-437d-bd0d-01b23bf01661 | test-1 | ACTIVE | - | Running | public1=10.0.2.150 || dd773d0e-fe5e-47d2-b5b0-aafbaab5b41b | test-2 | ACTIVE | - | Running | public1=10.0.2.157 |+--------------------------------------+--------+--------+------------+-------------+--------------------+ 4.挂载multiattach_volume到两个虚拟机1234567891011121314151617181920[root@queens ~]# nova volume-attach 4203f1d1-1511-437d-bd0d-01b23bf01661 d93e1565-6dd2-442a-a017-f1dc5cc91d86+----------+--------------------------------------+| Property | Value |+----------+--------------------------------------+| device | /dev/vdb || id | d93e1565-6dd2-442a-a017-f1dc5cc91d86 || serverId | 4203f1d1-1511-437d-bd0d-01b23bf01661 || volumeId | d93e1565-6dd2-442a-a017-f1dc5cc91d86 |+----------+--------------------------------------+[root@queens ~]# nova volume-attach dd773d0e-fe5e-47d2-b5b0-aafbaab5b41b d93e1565-6dd2-442a-a017-f1dc5cc91d86+----------+--------------------------------------+| Property | Value |+----------+--------------------------------------+| device | /dev/vdb || id | d93e1565-6dd2-442a-a017-f1dc5cc91d86 || serverId | dd773d0e-fe5e-47d2-b5b0-aafbaab5b41b || volumeId | d93e1565-6dd2-442a-a017-f1dc5cc91d86 |+----------+--------------------------------------+ 5.查看卷信息，可以看到被挂载在两个虚拟机上12345678910111213141516171819202122232425262728293031[root@queens ~]# cinder show d93e1565-6dd2-442a-a017-f1dc5cc91d86+--------------------------------+----------------------------------------------------------------------------------+| Property | Value |+--------------------------------+----------------------------------------------------------------------------------+| attached_servers | ['4203f1d1-1511-437d-bd0d-01b23bf01661', 'dd773d0e-fe5e-47d2-b5b0-aafbaab5b41b'] || attachment_ids | ['26631abb-cfb4-48a8-9da2-30bb47f26905', 'fc0cbde4-2496-4123-a020-a409ac93b83d'] || availability_zone | nova || bootable | false || consistencygroup_id | None || created_at | 2018-04-11T09:13:57.000000 || description | None || encrypted | False || id | d93e1565-6dd2-442a-a017-f1dc5cc91d86 || metadata | attached_mode : rw || migration_status | None || multiattach | True || name | multiattach_volume || os-vol-host-attr:host | queens@lvm-1#lvm-1 || os-vol-mig-status-attr:migstat | None || os-vol-mig-status-attr:name_id | None || os-vol-tenant-attr:tenant_id | fbe246bc04a146928d8ecaf0e32d8eec || replication_status | None || size | 1 || snapshot_id | None || source_volid | None || status | in-use || updated_at | 2018-04-11T09:16:02.000000 || user_id | 7593374948ec463fa09a71a24c82c69e || volume_type | multiattach |+--------------------------------+----------------------------------------------------------------------------------进入两个虚拟机系统可以看到该磁盘信息。 6.测试HA1.进入第一个虚拟机系统分区、格式化、挂载到/mnt并写入文件。2.模拟虚拟机故障，然后进入第二个虚拟机系统挂载分区，查看文件。可以看到第一个虚拟机写入的文件，并能继续写入。 7.Known issues and limitations Retyping an in-use volume from a multiattach-capable type to a non-multiattach-capable type, or vice-versa, is not supported. It is not recommended to retype an in-use multiattach volume if that volume has more than one active read/write attachment.","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengshaojin.com/categories/技术/"}],"tags":[{"name":"openstack","slug":"openstack","permalink":"http://www.chengshaojin.com/tags/openstack/"}]},{"title":"那些看一眼就惊艳了时光的诗句","date":"2018-03-31T13:17:11.000Z","path":"2018/03/31/那些一眼就惊艳了时光的诗句/","text":"十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候、在天涯。白露收残暑，清风衬晚霞。绿杨堤畔闹荷花。记得年时沽酒、那人家。 ——《南柯子 十里青山远》仲殊 兜兜转转两三年，如今三年不似那三年。偷的半日的时光，在那十里的果园里笑开了花。 把酒祝东风，且共从容。垂杨紫陌洛城东。总是当时携手处，游遍芳丛。聚散苦匆匆，此恨无穷。今年花胜去年红。可惜明年花更好，知与谁同？ ——《浪淘沙 把酒祝东风》欧阳修 年年岁岁花相似，岁岁年年人不同。愿未来如你所期，不负时光不忘初心。 沧海蓝田共烟霞，珠玉冷暖在谁家。金人莫论兴衰事，铜仙惯乘来去车。孤艇酒酣焚经典，高枝月明判凤鸦。蓬莱枯死三千树，为君重满碧桃花。 ——摘自木心作品《西班牙三棵树》 蓬莱枯死三千树，为君重满碧桃花。 哀利丝•霍珈走过来悄悄说，如果有人欺侮你，你就种一棵树——这也太美丽得犬儒主义的春天似的；我是，这样想，当谁欺侮了谁时，神灵便暗中播一棵树，森林是这样形成的，谁树即谁人，却又都不知道。 一别都门三改火，天涯踏尽红尘。依然一笑作春温。无波真古井，有节是秋筠。惆怅孤帆连夜发，送行淡月微云。樽前不用翠眉颦。人生如逆旅，我亦是行人。 ——《临江仙·送钱穆父》苏轼 常羡人间琢玉郎，天应乞与点酥娘。尽道清歌传皓齿，风起，雪飞炎海变清凉。万里归来颜愈少，微笑，笑时犹带岭梅香。试问岭南应不好，却道：此心安处是吾乡。 ——《定风波 南海归赠王定国侍人寓娘》苏轼 细雨斜风作晓寒，淡烟疏柳媚晴滩。入淮清洛渐漫漫。雪沫乳花浮午盏，蓼茸蒿笋试春盘。人间有味是清欢。 ——《浣溪沙 细雨斜风作晓寒》苏轼 人间有味是清欢 瀑布的水逆流而上，蒲公英种子从远处飘回，聚成伞的模样，太阳从西边升起，落向东方。 子弹退回枪膛，运动员回到起跑线上，我交回录取通知书，忘了十年寒窗。 厨房里飘来饭菜的香，你把我的卷子签好名字，关掉电视，帮我把书包背上。 你还在我身旁 。 ——《你还在我身旁》香港中文大学学生作品","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengshaojin.com/categories/生活/"}],"tags":[{"name":"诗句","slug":"诗句","permalink":"http://www.chengshaojin.com/tags/诗句/"}]},{"title":"openstack配置lvm与nfs的cinder多后端","date":"2018-03-14T08:39:14.000Z","path":"2018/03/14/openstack配置lvm与nfs的cinder多后端/","text":"不知道自己习惯还是怎么，潜意识里总觉得openstack与ceph是最配的一对，平时测试自己玩都是ceph做后端，最近有个客户的POC，明确要求用lvm，而且他们用的存储还都是nfs，所以我就测试了下用lvm与nfs做cinder的多后端，以此记录。测试openstack环境还是用kolla部署的pika版,先使用lvm做cinder后端，然后再配置nfs。 在每个存储节点准备一块单独的盘创建 volume group12# pvcreate /dev/sdb# vgcreate cinder-volume /dev/sdb 在global文件中打开lvmenable_cinder_backend_lvm: &quot;yes&quot; lvm的配置就这么多，要注意的是你的vg的名字必须和global文件中cinder_volume_group的名字一致。cat /etc/kolla/globals.yml | grep cinder_volume cinder_volume_group: “cinder-volumes”在cinder后端不使用ceph的时候，global文件里默认glance存储在本地文件里。 配置nfs安装nfs,确保nfs与rpcbind服务正常,确认nfs设备创建成功，能够挂载并有读写权限，可以在/etc/exports文件中这么写：/mnt/share 192.168.226.0/24(rw,sync,no_root_squash)1mount -t nfs 192.168.226.128:/mnt/share /nfs_shares 在cinder.conf文件中做如下配置：1234567891011vi /etc/kolla/cinder-volume/cinder.conf[DEFAULT]enabled_backends = nfs[nfs]volume_backend_name = nfsvolume_driver = cinder.volume.drivers.nfs.NfsDrivernas_host = 192.168.226.128nas_share_path = /mnt/sharenfs_mount_attempts = 3 重启cinder_volume容器，查看日志看是否加载成功。 创建两个cinder卷类型12345678910# source /etc/kolla/admin-openrc.sh# cinder type-create lvm# cinder type-create nfs# cinder type-list+--------------------------------------+------+-------------+-----------+| ID | Name | Description | Is_Public |+--------------------------------------+------+-------------+-----------+| c9936b51-aaf1-4822-80fe-f0a1d91196bf | lvm | - | True || cf3a55be-a32c-412d-9175-33e1bd33f45b | nfs | - | True |+--------------------------------------+------+-------------+-----------+ 设置卷类型的key键值123456789# cinder type-key lvm set volume_backend_name=lvm-1# cinder type-key nfs set volume_backend_name=nfs-1# cinder extra-specs-list+--------------------------------------+------+----------------------------------+| ID | Name | extra_specs |+--------------------------------------+------+----------------------------------+| c9936b51-aaf1-4822-80fe-f0a1d91196bf | lvm | &#123;'volume_backend_name': 'lvm-1'&#125; || cf3a55be-a32c-412d-9175-33e1bd33f45b | nfs | &#123;'volume_backend_name': 'nfs-1'&#125; |+--------------------------------------+------+----------------------------------+ 在dashboard创建卷的时候就可以选择使用哪种后端： 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# cinder create --volume_type lvm --display_name volume_lvm 1+--------------------------------+--------------------------------------+| Property | Value |+--------------------------------+--------------------------------------+| attachments | [] || availability_zone | nova || bootable | false || consistencygroup_id | None || created_at | 2018-03-14T17:31:28.000000 || description | None || encrypted | False || id | a17fde61-02a3-48ff-ba10-98908770704b || metadata | &#123;&#125; || migration_status | None || multiattach | False || name | volume_lvm || os-vol-host-attr:host | None || os-vol-mig-status-attr:migstat | None || os-vol-mig-status-attr:name_id | None || os-vol-tenant-attr:tenant_id | c0875c01f9394cffac2f83c43bce2e80 || replication_status | None || size | 1 || snapshot_id | None || source_volid | None || status | creating || updated_at | None || user_id | 586c61eb3200477b9c03a22cd9baea50 || volume_type | lvm |+--------------------------------+--------------------------------------+# cinder create --volume_type nfs --display_name volume_nfs 1+--------------------------------+--------------------------------------+| Property | Value |+--------------------------------+--------------------------------------+| attachments | [] || availability_zone | nova || bootable | false || consistencygroup_id | None || created_at | 2018-03-14T17:33:13.000000 || description | None || encrypted | False || id | 360865c0-90d3-4c69-b463-c5771d39962e || metadata | &#123;&#125; || migration_status | None || multiattach | False || name | volume_nfs || os-vol-host-attr:host | None || os-vol-mig-status-attr:migstat | None || os-vol-mig-status-attr:name_id | None || os-vol-tenant-attr:tenant_id | c0875c01f9394cffac2f83c43bce2e80 || replication_status | None || size | 1 || snapshot_id | None || source_volid | None || status | creating || updated_at | None || user_id | 586c61eb3200477b9c03a22cd9baea50 || volume_type | nfs |+--------------------------------+--------------------------------------+ 到此cinder的lvm与nfs多后端配置完成。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengshaojin.com/categories/技术/"}],"tags":[{"name":"openstack","slug":"openstack","permalink":"http://www.chengshaojin.com/tags/openstack/"}]},{"title":"2018年春节前最后一天上班的晚上","date":"2018-02-09T15:04:34.000Z","path":"2018/02/09/2018年春节前最后一天上班的晚上/","text":"晚上收拾了下明天回家的行李，想想一年就这样又过去了，是不是应该总结一下过去一年的得失、荣辱、希望和失望，这样也给自己一种仪式感，写一写感悟，谈一谈一年中的改变，想一想18年应该做哪些事，提醒自己不负时光，能光明前进。 慢慢静下心来，匆匆2018年也已经是2月份了，这两月工作不是特别的忙，上班时间基本也是自己安排，也让自己放松了很多，下班后都是看小说，没干什么正事，熬了几个夜晚看完了曾国藩三部曲，导致自己最近总是爱琢磨别人说的话到底有什么深层意思，其实也没有什么意思，平常人哪有那么高深莫测，没干啥事反而让自己很累。后来就自己劝自己我等凡夫俗子就别想那么多了，别人一张口就知道人家心里想什么的内家本事，没个几十年的功力哪能轻易练成，哈哈。开个玩笑，还是说说自己到底干了什么吧。 关于工作这一年发生最重要的事就是在十月份换了工作，这是我没有想到的，虽然依然在同一个行业，但在一家公司呆的时间太短总不是一件太好的事，再说当时的领导对初入职场的我在做人做事各方面有很大的帮助，很多事都是亲历亲为的教我们，我很感谢他，希望他在新的一年工作顺利，身体健康。然后因为很多其他原因，当然也有一部分我自己的原因，就匆匆辞职了换了一份工作，依然在做openstack运维实施方面的工作。其实当时刚毕业的时候自己真的是十分的迷茫，不知道自己能干什么，看到openstack正如日中天，就开始学习，现在也能因此谋得一份工作也感到十分的庆幸。即使openstack呈下落趋势，任何开源项目都有其上升期和下降期，但是现在也会因为工作需要去不断的学习新的知识，不再因为不知道自己能干什么想干什么而迷茫，我想这应该是自己这一年最大的收获吧。 其实工作中能识人然后正确的待人也是工作实力的一部分，刚出校门的我，因为说话做事太直，吃了不少的亏，吃一斩长一智嘛，现在想来其实吃吃亏也是蛮好的。让自己认识到自己情商的严重不足，应该注意慢慢提高。我也一直在提醒自己要不忘初心，做人做事要有自己的底线，不要变得太圆滑，成为自己以前讨厌的人。 关于生活离开校园生活变得非常规律了，以前在学校总是抽烟，现在也不抽了，其实我是没有烟瘾的，所以说戒就戒了。自从离开学校开始租房子了，周末有时间就开始自己做饭了，这一点是我非常开心的，生活的情趣来源于不断的创造，尤其当你做出一盘色香味俱全的菜的时候，那种成就感是不由而生的。由此也感受到，其实每天做饭也是一件非常耗时间的，而且加上洗锅也是比较累的，做饭的时候信心满满，但是吃完就不想洗锅了，哈哈，争取以后就买自动洗碗机了，看了网上的评论，说是还不错。一年也没怎么出去旅行，大学的时候没钱，反而经常出去玩，在北京一年多，连北京市也没怎么玩过，国庆放假的时候计划好了出去，结果加了四天班，也再没心情出去了，以后心态有待改正，不工作的时候还是应该多出去看看的，尤其一些自然风景区，大自然自带一种开阔心胸的功能。唯一遗憾的就是自从毕业就很少再踢球了，这项占据了大学最多时间的运动，现在却很少去踢了。我也能感觉到身体机能大不如以前了，总想着去锻炼，但都是时间用来做了其他事了，其实归根结底还是太懒了。很怀念当年参加大学生运动会的时候跟球队吃住在一起的日子以及每天下午在操场练球的日子。 2018年计划要做的：1.学驾照。虽说人工智能的突飞猛进已经实现了无人驾驶，但还是想体验驾驶的乐趣。一定要做的。2.学习python语言。简直刻不容缓啊。3.能初学投资，虽然没钱，但我也有一颗想实现财富自由的心啊。4.能读20本以上的书。20本应该很少了，比不了大神，自己开心就好，貌似最近没咋上心工作，下班已经读了三四本了吧，主要是必须要完成，没有上线，不要辜负了自己的kindle。哈哈。5.提高自己的厨艺，会做菜品的数量有待丰富，没有多大要求，能满足家常就好了。 絮絮叨叨没说啥正事，感觉都是废话啊。。。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengshaojin.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.chengshaojin.com/tags/生活/"}]},{"title":"docker单机环境下的网络与通信","date":"2018-01-22T02:09:14.000Z","path":"2018/01/22/docker单机环境下的网络与通信/","text":"一、docker单机环境的下的网络1.三种原生网络docker提供三种原生网络，在安装的时候就会自动在host创建三个网络，用 docker network ls 命令查看，分别是：bridge、host、none。在创建容器的时候可以通过--network=none/host/bridge 来指定使用哪一种网络。例如： # docker run -it --network=none busybox none网络：什么都没有的网络，这个网络的容器只有一个lo网卡，是一个网络封闭的容器，对一些安全性较高，不需要联网的应用可以使用none网络。host网络：使用host网络的容器与主机的网络配置完全一样，连hostname都一样。host网络的好处是性能好，但是不够灵活。比如端口与host会冲突.bridge网络：安装docker的时候都会默认创建一个 docker0 的linux bridge，如果不指定网络，默认创建的容器的网络都会挂在 docker0 上。bridge网络的容器有一对veth pair,是一对连起来的网卡，一边在容器里，一边挂在host的docker0 上，这样相当于容器里的一头也挂在 docker0 上。用 docker network inspect bridge 看下bridge网络的配置信息，可以看到bridge网络配置的subnet、网关等信息。 2.自定义网络除了上述三种docker自动创建的网络，用户也可以根据业务需求自定义网络。docker提供三种user-defined网络驱动：bridge、overlay、macvlan。overlay与 macvlan用于创建跨主机网络。通过创建bridge驱动来创建bridge网络，ip网段由docker0自动分配，例如： # docker network create --driver bridge my_net1 也可以通过--subnet 和--gateway 自己指定Ip网段： # docker network create --driver bridge --subnet 172.18.22.0/24 --gateway 172.18.22.1 my_net2 使用自定义的网络也是通过--network 指定，容器中的ip 既可以自动分配也可以在启动容器的时候使用 --ip 指定ip。 # docker run -it --network=my_net2 --ip 172.18.22.8 busybox # docker run -it --network=my_net2 centos 注：只有使用--subnet 创建的网络才能指定静态ip。 二、单机环境下容器之间的通信我们可以想到，挂在同一个bridge上的容器网段和网关都相同，肯定是可以互通的，比如使用上述的my_net2网络的两个容器busybox和centos应该是互通的，事实上也是如此。但是分别使用my_net1和my_net2的两个不同网段的容器能通吗？，答案当然是不行！那么怎么才能让他们互通呢？打开路由转发，加一条路由？这样按理来说应该是可以的，但是事实上加了路由，打开路由转发也不通。这就是docker不同网络的隔离性。docker在iptables上drop了两个网桥之间的双向流向。那么到底怎么样两个不同网段的容器才能通信呢？只有加一块网卡了。在一个容器里加一块另一个网桥的网卡，通过这块网卡与另一个容器通信。 容器之间的三种通信方式1.IP通信如上所说，在创建容器时通过--network 指定相应的网络，或者通过 docker network connect 将现有容器加入指定网络，并且都是同一个网络的网卡，这样两个容器就可以通信了。 2.Docker DNS Serverdocker 自带 DNS服务，使容器可以直接通过“容器名”通信。 # docker run -it --network=my_net2 --name=bbox1 busybox # docker run -it --network=my_net2 --name=bbox2 busybox 在bbox1里pingbbox2 可以通 # ping bbox2 注：使用DNS 只能在 user-defined网络中使用，默认的Bridge不能使用。 3.joined 容器joined容器通过容器之间共享网卡和配置信息，通过127.0.0.1来直接通信。 # docker run -d -it --name=web1 httpd # docker run -it --network=container:web1 busybox 这样两个容器内的网卡mac与ip完全一样，busybox可以直接使用127.0.0.1访问web1的httpd服务。 这种通信方式适合以下场景： 1）.不同容器中的应用程序希望高效快速的通信，比如web server与app server。 2）.希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。 三、容器与外网的通信容器与外网的通信其实与其他环境与外网的通信一样的，通过 NAT 访问外网，通过 端口映射 使外网访问容器。 1.容器访问外网主机可以访问外网的情况下，使用默认bridge网络的容器默认也能通外网，关键我们理解下通外网的本职：通过 # iptables -t nat -S 可以看到：当使用docker0 这个网桥的bridge网络的容器，向外Ping的时候，docker0收到容器网段的外出包，把它给masquerade处理，而MASQUERADE将包的源地址转换成host的地址发送出去，即做一次网络地址转发。 2.外网访问容器docker 可将容器对外提供服务的端口映射到 host 的某个端口，外网通过该端口访问容器。容器启动时通过-p参数映射端口： # docker run -d -p 80 httpd 容器启动后，可通过 docker ps 或者 docker port 查看到 host 映射的端口。在上面的例子中，httpd 容器的 80 端口被映射到 host 32773 上，这样就可以通过 : 访问容器的 web 服务了。除了映射动态端口，也可在-p 中指定映射到 host 某个特定端口，例如可将 80 端口映射到 host 的 8080 端口：docker run -d -p 8080:80 httpd","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengshaojin.com/categories/技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.chengshaojin.com/tags/docker/"}]},{"title":"docker学习笔记（二）","date":"2018-01-20T07:48:57.000Z","path":"2018/01/20/docker基础（二）/","text":"docker底层最重要的两种技术分别是cgroup和namespace,cgroup实现资源限额，namespace实现资源隔离。cgroup可以设置进程使用cpu、内存和io资源的限额，而namespace使得每个容器都觉得自己在独立的使用主机资源，所以实现了容器间资源的隔离。linux的六种namespace对应六种资源：mount、UTS、IPC、PID、Network和User。 而cgroup对资源限额的使用主要体现在以下方面 1.对内存的限额。与操作系统类似，容器使用的内存包括物理内存和swap两种。 -m 或 –memory 设置内存的使用限额 –memory-swap 设置内存+swap的使用限额 如下：123 # docker run -m 200M --memory-swap=300M centos表示运行centos容器，允许该容器使用内存最多200M，swap最多100M。默认情况这两组参数为-1，即不限额。如果启动容器的时候只指定 -m 而不指定 --memory-swap，那么默认 --memory-swap为-m的两倍， 2.对cpu的限额默认情况，所有容器平等使用host的cpu资源没有限制。-c 或 –cpu-share 可以设置容器使用cpu的权重。不指定的话默认值为1024,也就是说 -c 参数并不能为容器设置cpu的绝对使用资源某个容器最终获取到的cpu资源由它占所有容器使用cpu综合的比例决定，如下：12345启动两个容器： # docker run --name \"container1\" -c 1024 centos # docker run --name \"container2\" -c 512 centos表明 container1容器可以得到2倍的container2容器的cpu资源。这只是在cpu资源紧张的时候，如果container1是关闭状态，container2依然可以使用全部的cpu资源 –cpu 可以设置cpu工作线程的数量，最大为host物理cpu个数。可以使用 progrium/stress 镜像来学习如何为容器分配内存和cpu。该镜像也可用于对容器执行压力测试1# docker run --name container1 -it -c 1024 progrium/stress --cpu 1 3.对block IO的限额Block IO 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽。默认情况下，所有容器能平等地读写磁盘，可以通过设置 –blkio-weight 参数来改变容器 block IO 的优先级。–blkio-weight与 –cpu-shares 类似，设置的是相对权重值，默认为 500。限制 bps 和 iops： bps 是 byte per second，每秒读写的数据量。 iops 是 io per second，每秒 IO 的次数。 可通过以下参数控制容器的 bps 和 iops： –device-read-bps，限制读某个设备的 bps。 –device-write-bps，限制写某个设备的 bps。 –device-read-iops，限制读某个设备的 iops。 –device-write-iops，限制写某个设备的 iops。12# docker run -it--device-write-bps /dev/sda:30MB centos 表明限制容器写 /dev/sda 的速率为 30 MB/s，可以通过dd测试。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengshaojin.com/categories/技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.chengshaojin.com/tags/docker/"}]},{"title":"docker学习笔记(一)","date":"2018-01-19T07:41:42.000Z","path":"2018/01/19/docker基础(一)/","text":"最近几个月乱七八糟的学习了很多docker的东西，零散繁杂，不经常用就会遗忘很多。加之，pass层的火热，kubernetes在容器编排方面看似已经无人能敌了，所以整理以下，作为技术储备，哈哈。 安装docker-ce安装基础包12# yum install epel-release -y# yum install axel vim git curl wget lrzsz gcc python-devel yum* python-pip 设置docker官方repo，安装docker CE版本1# yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 系统默认应该没有yum-config-manager,如果没有那就安装它 : yum -y install yum-utils12# yum install -y docker-ce # docker --version 配置docker12345# mkdir /etc/systemd/system/docker.service.d# tee /etc/systemd/system/docker.service.d/docker.conf &lt;&lt; 'EOF'[Service]MountFlags=sharedEOF 编辑 /usr/lib/systemd/system/docker.service12# ExecStart=/usr/bin/dockerdExecStart=/usr/bin/dockerd --insecure-registry 192.168.19.133:4000 启动docker1234# systemctl daemon-reload# systemctl restart docker# systemctl enable docker# docker info 搭建私有仓库12# docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 \\--restart=always --name registry registry:2 docker容器的几点特别的地方我们都知道docker容器是轻量级的，那么体现在哪些地方呢？1.docker容器与host共用kernel,也就是说docker容器里是没有kernel空间的，只有rootfs，也就是我们常见的/dev、/usr、/bin这类东西，所以容器里是不能升级kernel的。2.镜像的分层结构。绝大部分的docker镜像都是从base镜像中配置安装所需软件而来的，每配置安装一个软件，就在现有的镜像基础上增加一层，新镜像就是从base镜像一层一层叠加而来,而且每一层都是共享的，这样内存中只需存一份base镜像就可以了。当用某个镜像启动一个容器的时候，就会在镜像层之上生成一个容器层，所有对容器的操作都是在容器层，而不会对镜像层有任何改变。所以，镜像可以被多个容器共享。 容器的一些常用操作运行容器1234# docker run -it 镜像 /bin/bash 以交互模式启动并进入一个容器 参数： -d 以后台方式启动容器 --name 给启动的容器命名 进入容器的两种方法12# docker attach 长id# docker exec -it 容器名/长id/短id bash attach 与 exec 主要区别如下: 1.attach 直接进入容器 启动命令 的终端，不会启动新的进程。 2.exec 则是在容器中打开新的终端，并且可以启动新的进程。 如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。当然，如果只是为了查看启动命令的输出，可以用 docker logs 命令 容器的常用操作123# docker stop/start/restart 容器 # docker pause/unpause 容器 # docker rm 容器","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengshaojin.com/categories/技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.chengshaojin.com/tags/docker/"}]},{"title":"kolla部署openstack的pika版","date":"2018-01-18T08:44:28.000Z","path":"2018/01/18/kolla部署openstack的pika版/","text":"用kolla部署openstack真的是超级方便简单，想当年初识openstack的时候我可是用了两周多的时间才搭建起一套没有HA的环境，可今天下午，如果不算下载docker镜像的时间，我只用不到两小时的时间就部署起一套openstack+ceph的高可用融合型环境。kolla本身将openstack包括ceph的所用服务都容器化，所有你要启动某个服务，只需要重启该服务的容器就好了。而且kolla是唯一一个没有任何厂商背景的部署工具，完全开源，已经非常成熟了，我所在公司九州云，已经部署了n多的生产案例了，扩容按理来说应该也是比较方便的。贴上同事整理的部署文档，你只需要仔细一点，按照此方法应该都是可以部署成功的，所以就不多说了。https://www.lijiawang.org/posts/kolla-pike-on-centos.html 关于网络123456789kolla定义网络是在/etc/kolla/global.yml文件中,只需在相关网络的后面写上实际的物理网卡名字就可以了，如下：network_interface: \"eno16777736\" 管理网api_interface: \"&#123;&#123; network_interface &#125;&#125;\"storage_interface: \"&#123;&#123; network_interface &#125;&#125;\" 存储网cluster_interface: \"&#123;&#123; network_interface &#125;&#125;\" 存储集群网tunnel_interface: \"&#123;&#123; network_interface &#125;&#125;\" dns_interface: \"&#123;&#123; network_interface &#125;&#125;\" vxlan网neutron_external_interface: \"eno33554960\" private网网络可以分离，也可以用同一块，但是最少应该两块网卡，因为private网络需要独立。如果你做了网卡绑定的话，就换成bond0或bond1等 关于节点信息12345678910关于节点的定义信息是在multinode文件中，在此文件中你可以用hostname来定义哪些物理机是control,哪些是compute，哪些是storage，哪些是network等等，你可以定义openstack的服务安装在哪些节点上。如下：[control]control01control02control03表示control01、control02、control03是控制节点，control01、control02、control03是三个节点的hostname。[keystone:children]control表示keystone服务安装在所有的control节点 关于要安装哪些组件1234567891011121314这个功能也在global.yml文件中定义，如下：enable_barbican: \"no\"enable_ceilometer: \"yes\"enable_central_logging: \"yes\"enable_ceph: \"yes\"enable_ceph_rgw: \"yes\"enable_chrony: \"yes\"enable_cinder: \"yes\"enable_cinder_backend_hnas_iscsi: \"no\"enable_cinder_backend_hnas_nfs: \"no\"enable_cinder_backend_iscsi: \"no\"enable_cinder_backend_lvm: \"no\"enable_cinder_backend_nfs: \"no\"如果你想安装哪个组件，只需要将该组件行的注释去掉，冒号里写yes即可 当这些都定义完就可以deploy了，你可以在deploy之前先prechecks下，防止一些语法错误。再多说一点，1234567在你已经部署完成的情况下，如果要更改global.yml文件，改完以后执行以下命令：kolla-ansible upgrade -i multinodekolla-ansible post-deploy -i multinode如果修改了/etc/config/[server]/[server].conf文件：kolla-ansible reconfigure -i multinode如果部署失败，可以清除然后重新部署，清除的命令是：kolla-ansible destroy -i multinode --yes-i-really-really-mean-it","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengshaojin.com/categories/技术/"}],"tags":[{"name":"openstack","slug":"openstack","permalink":"http://www.chengshaojin.com/tags/openstack/"}]},{"title":"Linux字符管理命令","date":"2018-01-09T04:23:18.000Z","path":"2018/01/09/Linux字符管理命令/","text":"平时工作中经常用到grep、awk、sort、sed等字符管理命令，但是自己记性又不好，每次需要去google，索性总结一下，方便以后查询。 cut 截取所需字符-d “n”:定义分界符,即点位-f n:取第几位的字符1234例如：以空格符为分界符,进行第2位截取 cut -d \" \" -f 2 /etc/fstab 以冒号为分界符，进行第1，3位截取 cut -d \":\" -f 1,3 /etc/passwd sed 通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作1.关于替换： 1).sed替换的基本语法为: sed ‘s/原字符串/替换字符串/‘ filename s 表示替换 特殊字符需要使用反斜线“\\”进行转义，单引号是不能用反斜线转义，要用反斜线的话使用双引号。 要处理的字符串包含单引号也用双引号。 注意：在末尾加g替换每一个匹配的关键字，否则只替换每一行的第一个字符串12替换所有匹配关键字 sed 's/原字符串/替换字符串/g' filename 2）三根斜线也可换成别的符号，只要紧跟s定义即可12将分隔符换成问号”?”: sed 's?原字符串?替换字符串?' 注意：sed处理过的输出是直接输出到屏幕上的,使用参数”i”直接在文件中替换 3）多个替换可以在同一条命令中执行,用分号”;”分隔，其格式为:12同时执行两个替换规则 sed 's/^/添加的头部&amp;/g；s/$/&amp;添加的尾部/g' 4）一些特殊字符的使用 ”^”表示行首 ”$”符号如果在引号中表示行尾，但是在引号外却表示末行(最后一行)2.关于删除： 1）d 删除指定行,要在文件内删除，同样加参数i123456删除文件的第1-3行 sed '1,3d' filename 删除文件的第3行到最后一行 sed ‘3,$d’ filename 删除含有指定字段的行 sed '/字符/d' filename 3)多点编辑 使用-e参数12删除第1-3行，替换某字符 sed -e '1,3d' -e 's/原字符/替换的字符/' filename 4)文件操作1234将含有某字段的行写入新的文件中 sed -n '/某字段/w 新文件' filename 将小写改为大写 sed 'y/小写字母/大写字母/' filename awk 通过正则表达式,得到需要的行,列信息123456 查看df -h命令的第2列 df -h | awk '&#123;print $2&#125;' 查看df -h命令的第2,5列 df -h | awk '&#123;print $2,$5&#125;' 列示月份及年份(\\n为换行符) date | awk '&#123;print \"Year:\" $6 \"\\nMonth:\" $2&#125;' sort 默认以排序ASCII方式进行排序[a-z] 参数: -u 去除重复的行 -r 降序排序[z-a] -n 数值排序,默认情况10比2小,主要因为sort判断第一字符的值 -k 以文本的列进行判断 -t 设定分界符123456 对/etc/passwd文件进行升序排序 sort /etc/passwd 对/etc/passwd文件进行降序排序 sort -r /etc/passwd 对/etc/passwd第3列进行数值排序,分界符为: sort -n -k 3 -t : /etc/passwd wc 统计行数、字数、字符数、文件总统计数 参数: -l 统计行数 -c 统计字节数 -w 统计字数(单词数 uniq 检查文本中重复出现的行 -c 显示输出,并在文本行前加出现的次数,但如果 重复行不连续，则不认为是重复的行 -d 只显示重复的行 -u 只显示不重复的行 -f n前N个字段和每个字段前的空白行一起被忽略,字段从0开始编号 -s n 前N个字符被忽略,字符从0开始编号 -w n 对N个字符以后的字符不在检查重复性 tee 读取标准输入的数据，并将其内容输出成文件 说明:指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件 参数: -a:附加到既有文件的后面，而非覆盖它． -i:忽略中断信号。12 查询当前账户并写入who.txt文件中who | tee who.txt","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengshaojin.com/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.chengshaojin.com/tags/Linux/"}]}]
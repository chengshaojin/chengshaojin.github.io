[{"title":"docker学习笔记(一)","date":"2018-01-19T07:41:42.000Z","path":"2018/01/19/docker学习笔记(一)/","text":"最近几个月乱七八糟的学习了很多docker的东西，零散繁杂，不经常用就会遗忘很多。加之，pass层的火热，kubertnets看似已经无人能敌了，所以整理以下，作为技术储备，哈哈。 安装docker-ce12345678910111213141516171819202122232425安装基础包 # yum install epel-release -y # yum install axel vim git curl wget lrzsz gcc python-devel yum* python-pip设置docker官方repo，安装docker CE版本 # yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo系统默认应该没有yum-config-manager,如果没有那就安装它 : yum -y install yum-utils # yum install -y docker-ce # docker --version配置docker # mkdir /etc/systemd/system/docker.service.d # tee /etc/systemd/system/docker.service.d/docker.conf &lt;&lt; 'EOF' [Service] MountFlags=shared EOF编辑 /usr/lib/systemd/system/docker.service # ExecStart=/usr/bin/dockerd ExecStart=/usr/bin/dockerd --insecure-registry 192.168.19.133:4000启动docker # systemctl daemon-reload # systemctl restart docker # systemctl enable docker # docker info搭建私有仓库 # docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 \\ --restart=always --name registry registry:2 docker容器的几点特别的地方123456我们都知道docker容器是轻量级的，那么体现在哪些地方呢？ 1.docker容器与host共用kernel,也就是说docker容器里是没有kernel空间的，只有rootfs，也就是我们常见的/dev、/usr、/bin这类东西，所以容器里是不能升级kernel的。 2.镜像的分层结构。绝大部分的docker镜像都是从base镜像中配置安装所需软件而来的，每配置安装一个软件，就在现有的镜像基础上增加一层，新镜像就是从base镜像一层一层叠加而来,而且每一层都是共享的，这样内存中只需存一份base镜像就可以了。当用某个镜像启动一个容器的时候，就会在镜像层之上生成一个容器层，所有对容器的操作都是在容器层，而不会对镜像层有任何改变。所以，镜像可以被多个容器共享。 容器的一些常用操作12345678910111213141516171.运行容器 # docker run -it 镜像 /bin/bash 以交互模式启动并进入一个容器 参数： -d 以后台方式启动容器 --name 给启动的容器命名2.进入容器的两种方法 # docker attach 长id # docker exec -it 容器名/长id/短id bash attach 与 exec 主要区别如下: attach 直接进入容器 启动命令 的终端，不会启动新的进程。 exec 则是在容器中打开新的终端，并且可以启动新的进程。 如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。当然，如果只是为了查看启动命令的输出，可以使 用 docker logs 命令3.容器的常用操作 # docker stop/start/restart 容器 # docker pause/unpause 容器 # docker rm 容器","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"kolla部署openstack的pika版","date":"2018-01-18T08:44:28.000Z","path":"2018/01/18/kolla部署openstack的pika版/","text":"用kolla部署openstack真的是超级方便简单，想当年初识openstack的时候我可是用了两周多的时间才搭建起一套没有HA的环境，可今天下午，如果不算下载docker镜像的时间，我只用不到两小时的时间就部署起一套openstack+ceph的高可用融合型环境。kolla本身将openstack包括ceph的所用服务都容器化，所有你要启动某个服务，只需要重启该服务的容器就好了。而且kolla是唯一一个没有任何厂商背景的部署工具，完全开源，已经非常成熟了，我所在公司九州云，已经部署了n多的生产案例了，扩容按理来说应该也是比较方便的。贴上同事整理的部署文档，你只需要仔细一点，按照此方法应该都是可以部署成功的，所以就不多说了。https://www.lijiawang.org/posts/kolla-pike-on-centos.html 关于网络123456789kolla定义网络是在/etc/kolla/global.yml文件中,只需在相关网络的后面写上实际的物理网卡名字就可以了，如下：network_interface: \"eno16777736\" 管理网api_interface: \"&#123;&#123; network_interface &#125;&#125;\"storage_interface: \"&#123;&#123; network_interface &#125;&#125;\" 存储网cluster_interface: \"&#123;&#123; network_interface &#125;&#125;\" 存储集群网tunnel_interface: \"&#123;&#123; network_interface &#125;&#125;\" dns_interface: \"&#123;&#123; network_interface &#125;&#125;\" vxlan网neutron_external_interface: \"eno33554960\" private网网络可以分离，也可以用同一块，但是最少应该两块网卡，因为private网络需要独立。如果你做了网卡绑定的话，就换成bond0或bond1等 关于节点信息12345678910关于节点的定义信息是在multinode文件中，在此文件中你可以用hostname来定义哪些物理机是control,哪些是compute，哪些是storage，哪些是network等等，你可以定义openstack的服务安装在哪些节点上。如下：[control]control01control02control03表示control01、control02、control03是控制节点，control01、control02、control03是三个节点的hostname。[keystone:children]control表示keystone服务安装在所有的control节点 关于要安装哪些组件1234567891011121314这个功能也在global.yml文件中定义，如下：enable_barbican: \"no\"enable_ceilometer: \"yes\"enable_central_logging: \"yes\"enable_ceph: \"yes\"enable_ceph_rgw: \"yes\"enable_chrony: \"yes\"enable_cinder: \"yes\"enable_cinder_backend_hnas_iscsi: \"no\"enable_cinder_backend_hnas_nfs: \"no\"enable_cinder_backend_iscsi: \"no\"enable_cinder_backend_lvm: \"no\"enable_cinder_backend_nfs: \"no\"如果你想安装哪个组件，只需要将该组件行的注释去掉，冒号里写yes即可 当这些都定义完就可以deploy了，你可以在deploy之前先prechecks下，防止一些语法错误。再多说一点，1234567在你已经部署完成的情况下，如果要更改global.yml文件，改完以后执行以下命令：kolla-ansible upgrade -i multinodekolla-ansible post-deploy -i multinode如果修改了/etc/config/[server]/[server].conf文件：kolla-ansible reconfigure -i multinode如果部署失败，可以清除然后重新部署，清除的命令是：kolla-ansible destroy -i multinode --yes-i-really-really-mean-it","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"openstack","slug":"openstack","permalink":"http://yoursite.com/tags/openstack/"}]},{"title":"Linux字符管理命令","date":"2018-01-09T04:23:18.000Z","path":"2018/01/09/Linux字符管理命令/","text":"平时工作中经常用到grep、awk、sort、sed等字符管理命令，但是自己记性又不好，每次需要去google，索性总结一下，方便以后查询。 cut 截取所需字符-d “n”:定义分界符,即点位-f n:取第几位的字符1234例如：以空格符为分界符,进行第2位截取 cut -d \" \" -f 2 /etc/fstab 以冒号为分界符，进行第1，3位截取 cut -d \":\" -f 1,3 /etc/passwd sed 通过指定的正则表达式完成指定关键字的过滤、截取、修改等操作1.关于替换： 1).sed替换的基本语法为: sed ‘s/原字符串/替换字符串/‘ filename s 表示替换 特殊字符需要使用反斜线“\\”进行转义，单引号是不能用反斜线转义，要用反斜线的话使用双引号。 要处理的字符串包含单引号也用双引号。 注意：在末尾加g替换每一个匹配的关键字，否则只替换每一行的第一个字符串12替换所有匹配关键字 sed 's/原字符串/替换字符串/g' filename 2）三根斜线也可换成别的符号，只要紧跟s定义即可12将分隔符换成问号”?”: sed 's?原字符串?替换字符串?' 注意：sed处理过的输出是直接输出到屏幕上的,使用参数”i”直接在文件中替换 3）多个替换可以在同一条命令中执行,用分号”;”分隔，其格式为:12同时执行两个替换规则 sed 's/^/添加的头部&amp;/g；s/$/&amp;添加的尾部/g' 4）一些特殊字符的使用 ”^”表示行首 ”$”符号如果在引号中表示行尾，但是在引号外却表示末行(最后一行)2.关于删除： 1）d 删除指定行,要在文件内删除，同样加参数i123456删除文件的第1-3行 sed '1,3d' filename 删除文件的第3行到最后一行 sed ‘3,$d’ filename 删除含有指定字段的行 sed '/字符/d' filename 3)多点编辑 使用-e参数12删除第1-3行，替换某字符 sed -e '1,3d' -e 's/原字符/替换的字符/' filename 4)文件操作1234将含有某字段的行写入新的文件中 sed -n '/某字段/w 新文件' filename 将小写改为大写 sed 'y/小写字母/大写字母/' filename awk 通过正则表达式,得到需要的行,列信息123456 查看df -h命令的第2列 df -h | awk '&#123;print $2&#125;' 查看df -h命令的第2,5列 df -h | awk '&#123;print $2,$5&#125;' 列示月份及年份(\\n为换行符) date | awk '&#123;print \"Year:\" $6 \"\\nMonth:\" $2&#125;' sort 默认以排序ASCII方式进行排序[a-z] 参数: -u 去除重复的行 -r 降序排序[z-a] -n 数值排序,默认情况10比2小,主要因为sort判断第一字符的值 -k 以文本的列进行判断 -t 设定分界符123456 对/etc/passwd文件进行升序排序 sort /etc/passwd 对/etc/passwd文件进行降序排序 sort -r /etc/passwd 对/etc/passwd第3列进行数值排序,分界符为: sort -n -k 3 -t : /etc/passwd wc 统计行数、字数、字符数、文件总统计数 参数: -l 统计行数 -c 统计字节数 -w 统计字数(单词数 uniq 检查文本中重复出现的行 -c 显示输出,并在文本行前加出现的次数,但如果 重复行不连续，则不认为是重复的行 -d 只显示重复的行 -u 只显示不重复的行 -f n前N个字段和每个字段前的空白行一起被忽略,字段从0开始编号 -s n 前N个字符被忽略,字符从0开始编号 -w n 对N个字符以后的字符不在检查重复性 tee 读取标准输入的数据，并将其内容输出成文件 说明:指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件 参数: -a:附加到既有文件的后面，而非覆盖它． -i:忽略中断信号。12 查询当前账户并写入who.txt文件中who | tee who.txt","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]